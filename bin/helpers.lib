# shellcheck shell=sh

# Helpers shell library. Sources strict.lib by default when $STRICT is set.
#

[ "${STRICT-1}" -eq 0 ] || . strict.lib
. color.lib

# <html><h2>Bash Strict Mode</h2>
# <p><strong><code>$STRICT</code></strong> set to 0 when sourcing helpers.lib to not source strict.lib (Default: 1).</p>
# <h3>Examples</h3>
# <dl>
# <dt>To not source strict.lib:</dt>
# <dd>
# <pre><code class="language-bash">STRICT=0 . helpers.lib
# </code></pre>
# </dd>
# </dl>
# <h3>Links</h3>
# <ul>
# <li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/">Unofficial Bash Strict Mode</a></li>
# </ul>
# </html>
unset STRICT

####################################### + debug: DEBUG (default: unset), QUIET (default: unset)
# Show info message with > symbol in grey bold if DEBUG is set, unless QUIET is set
# Globals:
#   DEBUG              Show if DEBUG set, unless QUIET is set (default: unset).
#   GreyDim            Grey dimmed color for info message and > symbol.
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRY_RUN (default: unset).
#   Reset              Reset color.
# Arguments:
#   message            Message to show.
#   --man              Show help from man page and exit.
#   --desc             Show description from $DESC or header file comment and exit.
#   --manrepo          Show repository from man page and exit.
#   --vers             Show version from man page and exit.
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
# Output:
#   Message to stdout.
#######################################
debug() {
  if [ ! "${1-}" ] || [ "${PARSED-}" ]; then
    unset PARSE PARSED
    if test "${QUIET-0}" -ne 1 && test "${DEBUG-}"; then
# <html><h2>Show Debug Messages</h2>
# <p><strong><code>$DEBUG</code></strong> (Default: unset).</p>
# <p><strong><code>Debug messages are not shown if unset.</code></strong></p>
# <p>Activate with either of:</p>
# <ul>
# <li><code>DEBUG=1</code></li>
# <li><code>--debug</code></li>
# </ul>
# </html>
        DEBUG=1
        add=''; content=''; line=''; sep=' '
        sets="$(set +o | tr '\n' ';')"
        set +o nounset  # set +u
        add=""; content=""; suffix=""
        if command -v caller >/dev/null; then
          i=0
          while c="$(caller "${i}")"; do
            if [ "$(echo "${c}" | awk '{ print $2 }')" = 'die' ] \
              || [ "$(basename "$(echo "${c}" | awk '{ print $3 }')")" = 'helpers.lib' ]; then
              i="$((i+1))"
            else
              break
            fi
          done
          file="$(basename "$(echo "${c}" | awk '{ print $3 }')")"
          line="$(echo "${c}" | awk '{ print $1 }')"
        fi

        [ "${file-}" ] || file="$(basename "$(psargs '' | awk '{ print $1 }')" 2>/dev/null || true)"
        [ ! "${file-}" ] || add="$(greyinvert "${file}[${line}]"): "

        for arg do
          content="${content}${suffix}${arg}=$(eval echo "\$${arg}")"
          suffix=", "
        done

        if test -z "${content}" && test "${add}"; then
          add="${add%??}" # if no args, remove trailing ": "
        elif test -z "${content}"; then
          sep=''
        fi

        printf '%b\n' "$(greybold '!')${sep}${add}$(greydim "${content}")" >&2
        eval "${sets}"  # set -u, if it was set before
        unset add arg c content sep sets suffix
    fi
  else
    DESC='Show info message with + symbol in grey bold if DEBUG is set, unless QUIET is set' \
      PARSE='debug' parse "$@"
  fi
}

####################################### ✓|x die: QUIET (default: unset)
# Show message (success or error) with symbol (✓, x respectively) based on status code, unless QUIET is set and exit
# Globals:
#   Green              Green color for ✓ symbol.
#   PARSE              Function name or file.
#                      Default if BASH_VERSION: FUNCNAME[1] if BASH_SOURCE[1] is *.lib, otherwise BASH_SOURCE[1].
#   PARSED             Function called has been parsed already, run the function.
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRY_RUN (default: unset).
#   Red                Red color for error message and x symbol.
#   Reset              Reset color.
# Arguments:
#   message            Message to show.
#   --man              Show help from man page and exit.
#   --desc             Show description from $DESC or header file comment and exit.
#   --manrepo          Show repository from man page and exit.
#   --vers             Show version from man page and exit.
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
# Note:
#  Do not use command substitution in the message when false || die.
#  Previous error code is overwritten by the command substitution return code.
#  $ cd "$(dirname "${input}")" 2>/dev/null || die Directory not Found: "$(dirname "${input}")"
# Output:
#   Message to stderr if error and stdout for success.
# Returns:
#   1-255 for error, 0 for success.
#######################################
die() {
  rc=$?
  if [ ! "${1-}" ] || [ "${PARSED-}" ]; then
    unset PARSED
    rc="${firstrc:-${rc}}"
    if test "${QUIET-0}" -ne 1; then
      case "${rc}" in
        0) success "$@" ;;
        *) error "$@" ;;
      esac
    else
# <html><h2>Silent Output</h2>
# <p><strong><code>$QUIET</code></strong> (Default: unset).</p>
# <p><strong><code>The following messages are shown if unset:</code></strong></p>
# <ul>
# <li><code>error</code></li>
# <li><code>success</code></li>
# </ul>
# <p><strong><code>If unset or 0, other messages are shown base on the variable value:</code></strong></p>
# <ul>
# <li><code>debug</code>: $DEBUG</li>
# <li><code>verbose</code>: $VERBOSE</li>
# <li><code>warning</code>: $WARNING</li>
# </ul>
# <p>Activate with either of:</p>
# <ul>
# <li><code>QUIET=1</code></li>
# <li><code>--quiet</code></li>
# </ul>
# <p><strong><code>Note:</code></strong></p>
# <p>Takes precedence over $DEBUG, $VERBOSE and $WARNING.</p>
# </html>
      QUIET=1
    fi
    exit "${rc}"
  else
    # shellcheck disable=SC2034
    firstrc="${rc}"
    DESC="Show message (ok or error) with symbol (✓, x respectively) based on status code, unless QUIET is set \
and exit" PARSE='die' parse "$@"
  fi
}

####################################### x error: QUIET (default: unset)
# Show error message with x symbol in red, unless QUIET is set
# Globals:
#   PARSE              Function name or file.
#                      Default if BASH_VERSION: FUNCNAME[1] if BASH_SOURCE[1] is *.lib, otherwise BASH_SOURCE[1].
#   PARSED             Function called has been parsed already, run the function.
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRY_RUN (default: unset).
#   Red                Red color for error message and x symbol.
#   Reset              Reset color.
# Arguments:
#   message            Message to show.
#   --man              Show help from man page and exit.
#   --desc             Show description from $DESC or header file comment and exit.
#   --manrepo          Show repository from man page and exit.
#   --vers             Show version from man page and exit.
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
# Output:
#   Message to stderr.
#######################################
error() {
  if [ ! "${1-}" ] || [ "${PARSED-}" ]; then
    unset PARSED
    if test "${QUIET-0}" -ne 1; then
      add=''; line=''; sep=' '
      if command -v caller >/dev/null; then
        i=0
        while c="$(caller "${i}")"; do
          if [ "$(echo "${c}" | awk '{ print $2 }')" = 'die' ] \
            || [ "$(basename "$(echo "${c}" | awk '{ print $3 }')")" = 'helpers.lib' ]; then
            i="$((i+1))"
          else
            break
          fi
        done
        file="$(basename "$(echo "${c}" | awk '{ print $3 }')")"
        line="$(echo "${c}" | awk '{ print $1 }')"
      fi

      [ "${file-}" ] || file="$(basename "$(psargs '' | awk '{ print $1 }')" 2>/dev/null || true)"
      [ ! "${file-}" ] || add="$(redbg "${file}[${line}]"): "

      if test "$#" -eq 0 && test "${add}"; then
        add="${add%??}" # if no args, remove trailing ": "
      elif test "$#" -eq 0; then
        sep=''
      fi

      if test "${WHITE-}"; then
        test -z "${add}" || printf '%b\n' "$(redbold "x${sep}${add}")" >&2
        test "$#" -eq 0 || echo "$@" >&2
      else
         printf '%b\n' "$(redbold 'x')${sep}${add}$(redbold "$*")" >&2
      fi

      unset add c file line sep
    fi
  else
    DESC="Show error message with x symbol in red, unless QUIET is set" PARSE='error' parse "$@"
  fi
}

####################################### has
# Check if an executable exists.
# Arguments:
#   --all               Find all paths ('type -aP' or 'which -a' when 'type -a' is not available).
#   --binary            The first with shebang and not in sbin.
#   --path              Use path (ignore for '--all').
#   --value             Show value (ignore for '-a').
#   --exclude=<path>    Exclude executable (sets the '--all' option and returns all but exe)
#   executable          Executable to check (default: sudo if no image and not executable).
#   image               The image name (default: local).
# Common Arguments:
#   --man               Show help from man page and exit.
#   --desc              Show description from $DESC or header file comment and exit.
#   --manrepo           Show repository from man page and exit.
#   --vers              Show version from man page and exit.
# Optional Arguments:
#   --debug             Show debug messages.
#   --dryrun            Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet             Silent output.
#   --verbose           Show verbose messages.
#   --warning           Show warning messages.
# Returns:
#   1 if it does not exist.
#######################################
has() {
  if test "${QUIET-0}" -ne 1; then
    unset PARSED
    doc() { docker run -i --rm --entrypoint sh "${image}" -c "${c} ${executable}"; }
    loc() { ${c} "${executable}"; }

    all=false; binary=false; c='command -v'; p=false; t='type -aP'; v=false; w='which -a'
    for arg; do
      case "${arg}" in
        --all) all=true; c="${w}" ;;
        --binary) all=true; binary=true; c="${w}" ;;
        --path) c='which'; p=true ;;
        --value) v=true ;;
        --exclude=*) all=true; c="${w}"; exclude="$(echo "${arg}" | sed 's/--exclude=//')";;
        *)
          if [ "${executable-}" ]; then
            image="${arg}"
          elif [ "${arg:-}" != '' ]; then
            executable="${arg}"
          fi
          ;;
      esac
    done

    executable="${executable:-sudo}"

    if [ "${image-}" ] && $all; then
      if which docker >/dev/null 2>&1 || command -vp docker >/dev/null; then
        if docker run -i --rm --entrypoint sh "${image}" -c "${w} cut" >/dev/null 2>&1; then
          rv="$(doc)"; rc=$?
        else
          c="${t}"; rv="$(doc)"; rc=$?
        fi
      fi
    elif [ "${image-}" ]; then
      if $p; then
        if docker run -i --rm --entrypoint sh "${image}" -c "which cut" >/dev/null 2>&1; then
          rv="$(doc)"; rc=$?
        else
          c='type -P'; rv="$(doc)"; rc=$?
        fi
      else
        rv="$(doc)"; rc=$?
      fi
    elif $all; then
      if ${w} cut >/dev/null 2>&1; then
        rv="$(loc)"; rc=$?
      else
        c="${t}"; rv="$(loc)"; rc=$?
      fi
    else
      if $p; then
        if ${c} cut >/dev/null 2>&1; then
          rv="$(loc)"; rc=$?
        else
          c='type -P'; rv="$(loc)"; rc=$?
        fi
      else
        rv="$(loc)"; rc=$?
      fi
    fi

    if test "${rv-}"; then
      if $v; then
        echo "${rv}"

      elif $all; then
        tmp="$(mktemp)"
        for i in ${rv}; do
          real="$(real --resolved "${i}")"
          grep -q "^${real}$" "${tmp}" >/dev/null || echo "${real}" >> "${tmp}"
        done

        rv="$(cat "${tmp}")"

        if test "${binary-}"; then
          rc=1
          for i in $(echo "${rv}" | grep -v '/sbin/'); do
            head -1 "${i}" | grep -q '^#\!' || { rc=0; echo "${i}"; break; }
          done
        elif test "${exclude-}"; then
          rc=1
          real="$(real --resolved "${exclude}")"
          for i in ${rv}; do
            [ "${i}" = "${real}" ] || { rc=0; echo "${i}"; }
          done
        else
          echo "${rv}"
        fi
      fi
    fi
    unset all c executable i image real realp rv t tmp v w; unset -f doc loc
    return "${rc}" 2>/dev/null || exit "${rc}"
  else
    DESC='Check if an executable exists' PARSE='has' parse "$@"
  fi
}

####################################### parse
# Parse common long optional arguments.
# Globals:
#   PARSE              Function name or file.
#                      Default if BASH_VERSION: FUNCNAME[1] if BASH_SOURCE[1] is *.lib, otherwise BASH_SOURCE[1].
#   PARSED             Function called has been parsed already, run the function.
#   POSTPARSE          Variables to unset after each run of a function when parsed.
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRY_RUN (default: unset).
#   Red                Red color for error message and x symbol.
#   Reset              Reset color.
# Arguments:
#   -parse             As first argument indicates to parse for itself and expects only one long arguments,
#                      otherwise act as proxy (parse function).
#   --man              Show help from man page and exit.
#   --desc             Show description from $DESC or header file comment and exit.
#   --manrepo          Show repository from man page and exit.
#   --vers             Show version from man page and exit.
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
#   --white            Multi line error message.
# Output:
#   Message to stderr if error and stdout for success.
# Returns:
#   1-255 for error, 0 for success.
#######################################
# shellcheck disable=SC3028,SC3054
parse() {
  if [ "${1-}" ]; then
    unset _arg
    if [ "${#}" -eq 2 ] && [ "${1}" = '-parse' ]; then
      case "${2-}" in --desc|--man|--manrepo|--vers) shift;; esac
# <html><h2>Function one line Description</h2>
# <p><strong><code>$DESC</code></strong> contains the function description, for scripts is automatically extracted.</p>
# <p>Use <strong>$DESC</strong> to call `parse` from a function so it is shown when --desc argument is used.</p>
# <h3>Examples</h3>
# <dl>
# <dt>From a function:</dt>
# <dd>
# <pre><code class="language-bash">DESC='description'
# DESC='Function description' PARSE='function' parse &quot;$@&quot;
# </code></pre>
# </dd>
# </dl>
# </html>
      DESC='Parse common long optional arguments'
# <html><h2>Function Name or Full Script Path to Parse Arguments</h2>
# <p><strong><code>$PARSE</code></strong> contains the function name or script path ($0).</p>
# <p>Use <strong>$PARSE</strong> to call `parse` from a function or script in posix.</p>
# <p>If not set and BASH_VERSION, the following are used: </p>
# <ul>
# <li><code>FUNCNAME[1]: if BASH_SOURCE[1] =~ *.lib</code></li>
# <li><code>BASH_SOURCE[1]: if BASH_SOURCE[1] != *.lib</code></li>
# </ul>
# <h3>Examples</h3>
# <dl>
# <dt>From a function:</dt>
# <dd>
# <pre><code class="language-bash">if [ ! &quot;${1-}&quot; ] || [ &quot;${PARSED-}&quot; ]; then
# &emsp;unset PARSED
# &emsp;for arg do; case &quot;${arg}&quot; in --other-option) echo &quot;${arg}&quot; ;; esac; done
# else
# &emsp;DESC='description' PARSE='function' parse &quot;$@&quot;
# fi
# </code></pre>
# </dd>
# </dl>
# <dl>
# <dt>From a library when executed (needs more than one argument):</dt>
# <dd>
# <pre><code class="language-bash">if echo &quot;$0&quot;| grep -q 'name.lib'; then
# &emsp;if test &quot;$#&quot; -eq 0 || test &quot;${PARSED-}&quot;; then
# &emsp;&emsp;unset PARSED
# &emsp;&emsp;for arg do; case &quot;${arg}&quot; in --other-option) echo &quot;${arg}&quot; ;; esac; done
# &emsp;else
# &emsp;&emsp;PARSE=&quot;$0&quot; parse &quot;$@&quot;
# &emsp;fi
# fi
# </code></pre>
# </dd>
# </dl>
# <dl>
# <dt>From a script in sh:</dt>
# <dd>
# <pre><code class="language-bash">if [ ! &quot;${1-}&quot; ] || [ &quot;${PARSED-}&quot; ]; then
# &emsp;for arg do; case &quot;${arg}&quot; in --other-option) echo &quot;${arg}&quot; ;; esac; done
# &emsp; unset PARSED
# else
# &emsp;PARSE=&quot;${0}&quot; parse &quot;$@&quot;
# fi
# </code></pre>
# </dd>
# </dl>
# <dl>
# <dt>From a script in bash:</dt>
# <dd>
# <pre><code class="language-bash">if [ ! &quot;${1-}&quot; ] || [ &quot;${PARSED-}&quot; ]; then
# &emsp;for arg do; case &quot;${arg}&quot; in --other-option) echo &quot;${arg}&quot; ;; esac; done
# &emsp; unset PARSED
# else
# &emsp;parse &quot;$@&quot;
# fi
# </code></pre>
# </dd>
# </dl>
# </html>
      PARSE='parse'
    fi

    if [ "${PARSE-}" ]; then
# <html><h2>Arguments Parsed</h2>
# <p><strong><code>$PARSED</code></strong> will be set when arguments have been parsed to avoid recursion.</p>
# <p>Check if <strong>$PARSE</strong> is set before calling `parse` from a function or script.</p>
# <h3>Examples</h3>
# <dl>
# <dt>From a function:</dt>
# <dd>
# <pre><code class="language-bash">if [ ! &quot;${1-}&quot; ] || [ &quot;${PARSED-}&quot; ]; then
# &emsp;unset PARSED
# &emsp;for arg do; case &quot;${arg}&quot; in --other-option) echo &quot;${arg}&quot; ;; esac; done
# else
# &emsp;DESC='description' PARSE='function' parse &quot;$@&quot;
# fi
# </code></pre>
# </dd>
# </dl>
# <dl>
# <dt>From a library when executed:</dt>
# <dd>
# <pre><code class="language-bash">if echo &quot;$0&quot;| grep -q 'name.lib'; then
# &emsp;if test &quot;$#&quot; -eq 0 || test &quot;${PARSED-}&quot;; then
# &emsp;&emsp;unset PARSED
# &emsp;&emsp;for arg do; case &quot;${arg}&quot; in --other-option) echo &quot;${arg}&quot; ;; esac; done
# &emsp;else
# &emsp;&emsp;PARSE=&quot;$0&quot; parse &quot;$@&quot;
# &emsp;fi
# fi
# </code></pre>
# </dd>
# </dl>
# <dl>
# <dt>From a script in sh:</dt>
# <dd>
# <pre><code class="language-bash">if [ ! &quot;${1-}&quot; ] || [ &quot;${PARSED-}&quot; ]; then
# &emsp;unset PARSED
# &emsp;for arg do; case &quot;${arg}&quot; in --other-option) echo &quot;${arg}&quot; ;; esac; done
# else
# &emsp;PARSE=&quot;${0}&quot; parse &quot;$@&quot;
# fi
# </code></pre>
# </dd>
# </dl>
# <dl>
# <dt>From a script in bash:</dt>
# <dd>
# <pre><code class="language-bash">if [ ! &quot;${1-}&quot; ] || [ &quot;${PARSED-}&quot; ]; then
# &emsp;unset PARSED
# &emsp;for arg do; case &quot;${arg}&quot; in --other-option) echo &quot;${arg}&quot; ;; esac; done
# else
# &emsp;parse &quot;$@&quot;
# fi
# </code></pre>
# </dd>
# </dl>
# </html>
      unset PARSED
      if echo "${PARSE}" | grep -qE '^/'; then
        _path="${PARSE}"
        _cmd="$(basename "${_path}")"  # script.
      else
        _cmd="${PARSE}"
        _path="$(command -pv "${_cmd}" || false)"  # function: no path.
      fi
    elif [ "${BASH_VERSION-}" ]; then
      if echo "${BASH_SOURCE[1]}" | grep -q '.lib$' ; then
        _cmd="${FUNCNAME[1]}"  # function: path.
      else
        _cmd="$(basename "${BASH_SOURCE[1]}")"  # script.
      fi
      _path="${BASH_SOURCE[1]}"
    fi
    _variables='PARSED=1'
    _first=true
    for _arg do
      _skip=false
      shift
      set +x
      case "${_arg}" in
        --noquiet) _variables="${_variables} QUIET=0" ;;
        --debug|--dryrun|--quiet|--verbose|--warning|--white)
          _variables="${_variables} $(echo "${_arg}" | sed 's/--//' | tr '[:lower:]' '[:upper:]')=1"
          _skip=true
          ;;
        --desc)
          if $_first; then
            if [ ! "${DESC-}" ] && [ "${_path-}" ]; then
              DESC="$(awk '/^#/ && ! /^#!/ && ! /^##/ && ! /^#$/ && ! /^# shellcheck/ {sub(/^# /, ""); print $0=$0 }' \
                "${_path}" | head -1)"
            fi
            [ "${DESC-}" ] || exit
            echo "${DESC}"; exit
          fi
          ;;
         --man|--manrepo|--vers)
          if $_first; then
            _page="$(man -P cat "${_cmd}" 2>/dev/null || true)"
            [ "${_page:-}" ] || exit 1
            case "${_arg}" in
              --man) echo "${_page}" ;;
              --manrepo) echo "${_page}" | awk '/^REPOSITORY$/{ getline; print $1 }' ;;
              --vers) echo "${_page}" | tail -1 | awk '{ print $2 }' ;;
            esac
            exit
          fi
          ;;
      esac
      _first=false
      $_skip || set -- "$@" "${_arg}"
    done
    unset _arg DESC _page PARSE
    eval "${_variables} ${_path:-${_cmd}}" "\$@"
    eval_rc=$?
    if [ "${DRYRUN-}" ]; then
      # <html><h2>Dry Run</h2>
      # <p><strong><code>$DRYRUN</code></strong> (Default: unset).</p>
      # <p>Activate with either of:</p>
      # <ul>
      # <li><code>DRYRUN=1</code></li>
      # <li><code>--dryrun</code></li>
      # </ul>
      # </html>
      DRYRUN=1
    fi
    # FIXME: inline variables in centos sh remain after command: DEBUG=1 debug
    # _f() { if [ "${1-}" ]; then ${path:-${cmd}} "$@"; else ${path:-${cmd}}; fi; }
    # eval "${variables} _f" "\$@"
    return "${eval_rc}" 2>/dev/null || exit "${eval_rc}"
  fi
}

####################################### psargs
# Parent process args (cmd/command and args part of ps) if in a subshell or cmd of the current shell if running in a subshell.
# $$ is defined to return the process ID of the parent in a subshell; from the man page under "Special Parameters":
# expands to the process ID of the shell. In a () subshell, it expands to the process ID of the current shell,
# not the subshell.
# Arguments:
#   --usage             Show help message and exit.
# Outputs:
#   Process (ps) args.
# Returns:
#   1 if error during installation of procps or not know to install ps or --usage and not man page.
# ######################################
psargs() {
  if [ ! "${1-}" ] || [ "${PARSED-}" ]; then
    unset PARSED
    if command -v ps >/dev/null; then
      if ! ps -p $$ -o args= 2>/dev/null; then
        ps -o pid= -o args= | awk '/$$/ { $1=$1 };1' | grep "^$$ " | cut -d '' -f 2-
      fi
    fi
  else
    DESC='Parent process args (cmd/command and args part of ps)' PARSE='psargs' parse "$@"
  fi
}

####################################### ✓ success: QUIET (default: unset)
# Show success message in white with green ✓ symbol, unless QUIET is set
# Globals:
#   Green              Green color for ✓ symbol.
#   PARSE              Function name or file.
#                      Default if BASH_VERSION: FUNCNAME[1] if BASH_SOURCE[1] is *.lib, otherwise BASH_SOURCE[1].
#   PARSED             Function called has been parsed already, run the function.
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRY_RUN (default: unset).
#   Reset              Reset color.
# Arguments:
#   message            Message to show.
#   --man              Show help from man page and exit.
#   --desc             Show description from $DESC or header file comment and exit.
#   --manrepo          Show repository from man page and exit.
#   --vers             Show version from man page and exit.
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
# Output:
#   Message to stdout.
#######################################
success() {
  if [ ! "${1-}" ] || [ "${PARSED-}" ]; then
    unset PARSED
    if test "${QUIET-0}" -ne 1; then
      sep=''
      test "$#" -eq 0 || sep=' '
      printf '%b\n' "$(greenbold '✓')${sep}$*"
      unset sep
    fi
  else
    DESC="Show success message in white with green ✓ symbol, unless QUIET is set" PARSE='success' parse "$@"
  fi
}

####################################### > verbose: VERBOSE (default: unset), QUIET (default: unset)
# Show verbose/dry-run message with > symbol in grey dim if VERBOSE or DRY_RUN are set, unless QUIET is set
# Globals:
#   GreyDim            Grey dimmed color for info message and > symbol.
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRY_RUN (default: unset).
#   Reset              Reset color.
#   VERBOSE            Shows message if set, unless QUIET is set (default: unset).
# Arguments:
#   message            Message to show.
#   --man              Show help from man page and exit.
#   --desc             Show description from $DESC or header file comment and exit.
#   --manrepo          Show repository from man page and exit.
#   --vers             Show version from man page and exit.
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
# Output:
#   Message to stdout.
#######################################
verbose() {
  if [ ! "${1-}" ] || [ "${PARSED-}" ]; then
    unset PARSED
    if test "${QUIET-0}" -ne 1 && test "${VERBOSE-}"; then
# <html><h2>Show Verbose Messages</h2>
        # <p><strong><code>$VERBOSE</code></strong>  (Default: unset).</p>
        # <p><strong><code>Verbose messages are not shown if unset.</code></strong></p>
        # <p>Activate with either of:</p>
        # <ul>
        # <li><code>VERBOSE=1</code></li>
        # <li><code>--verbose</code></li>
        # </ul>
      # </html>
        VERBOSE=1
        sep=''
        test "$#" -eq 0 || sep=' '
        printf '%b\n' "$(cyanbold '>')${sep}$(cyandim "$*")"
        unset sep
    fi
  else
    DESC='Show verbose/dry-run message with > symbol in grey dim if VERBOSE or DRY_RUN are set, unless QUIET is set' \
      PARSE='verbose' parse "$@"
  fi
}

####################################### > warning: WARNING (default: unset), QUIET (default: unset)
# Show warning message with ! symbol in yellow if WARNING is set, unless QUIET is set
# Globals:
#   Yellow             Yellow color for warning message and ! symbol.
#   Reset              Reset color.
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRY_RUN (default: unset).
#   WARNING            Shows message if is set, unless QUIET is set (default: unset).
# Arguments:
#   message            Message to show.
#   --man              Show help from man page and exit.
#   --desc             Show description from $DESC or header file comment and exit.
#   --manrepo          Show repository from man page and exit.
#   --vers             Show version from man page and exit.
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
# Output:
#   Message to stderr.
#######################################
warning() {
  if [ ! "${1-}" ] || [ "${PARSED-}" ]; then
    unset PARSED
     if test "${QUIET-0}" -ne 1 && test "${WARNING-}"; then
# <html><h2>Show Warning Messages</h2>
# <p><strong><code>$WARNING</code></strong>  (Default: unset).</p>
# <p><strong><code>Warning messages are not shown if unset</code></strong></p>
# <p>Activate with either of:</p>
# <ul>
# <li><code>WARNING=1</code></li>
# <li><code>--warning</code></li>
# </ul>
# </html>
        WARNING=1
        add=''; line=''; sep=' '
        if command -v caller >/dev/null; then
          i=0
          while c="$(caller "${i}")"; do
            if [ "$(echo "${c}" | awk '{ print $2 }')" = 'die' ] \
              || [ "$(basename "$(echo "${c}" | awk '{ print $3 }')")" = 'helpers.lib' ]; then
              i="$((i+1))"
            else
              break
            fi
          done
          file="$(basename "$(echo "${c}" | awk '{ print $3 }')")"
          line="$(echo "${c}" | awk '{ print $1 }')"
        fi

        [ "${file-}" ] || file="$(basename "$(psargs '' | awk '{ print $1 }')" 2>/dev/null || true)"
        [ ! "${file-}" ] || add="$(yellowinvert "${file}[${line}]"): "

        if test "$#" -eq 0 && test "${add}"; then
          add="${add%??}" # if no args, remove trailing ": "
        elif test "$#" -eq 0; then
          sep=''
        fi

        printf '%b\n' "$(yellowbold '!')${sep}${add}$(yellowbold "$*")" >&2
        unset add c file line sep
    fi
  else
    DESC='Show warning message with ! symbol in yellow if WARNING is set, unless QUIET is set' \
      PARSE='warning' parse "$@"
  fi
}

####################################### Executed: force & parse
#
if echo "$0" | grep -q 'helpers.lib'; then
  if test "$#" -eq 0 || test "${PARSED-}"; then
    unset PARSE PARSED
    for arg do
      case "${arg}" in
        --force) FORCE=1 . "$0"
      esac
    done
  elif test "$#" -ne 0; then
    PARSE="$0" parse "$@"
  fi
fi
