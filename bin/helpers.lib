# shellcheck shell=sh

# Helpers shell library. Sources strict.lib by default when $STRICT is set.
#
[ "${STRICT-1}" -eq 0 ] || . strict.lib
. color.lib


# <html><h2>Bash Strict Mode</h2>
# <p><strong><code>$STRICT</code></strong> set to 0 when sourcing helpers.lib to not source strict.lib (Default: 1).</p>
# <h3>Examples</h3>
# <dl>
# <dt>To not source strict.lib:</dt>
# <dd>
# <pre><code class="language-bash">STRICT=0 . helpers.lib
# </code></pre>
# </dd>
# </dl>
# <h3>Links</h3>
# <ul>
# <li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/">Unofficial Bash Strict Mode</a></li>
# </ul>
# </html>
unset STRICT

####################################### + debug: DEBUG (default: unset), QUIET (default: unset)
# Show info message with > symbol in grey bold if DEBUG is set, unless QUIET is set
# Globals:
#   DEBUG              Show if DEBUG set, unless QUIET is set (default: unset).
#   GreyDim            Grey dimmed color for info message and > symbol.
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRYRUN (default: unset).
#   Reset              Reset color.
# Arguments:
#   message            Message to show.
#   --man              Show help from man page and exit.
#   --desc             Show description from $DESC or header file comment and exit.
#   --manrepo          Show repository from man page and exit.
#   --vers             Show version from man page and exit.
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
# Output:
#   Message to stdout.
#######################################
debug() {
  if test "$#" -eq 0 || { test "${1-}" = '--parsed' && shift; }; then
    if test "${QUIET-0}" -ne 1 && test "${DEBUG-}"; then
# <html><h2>Show Debug Messages</h2>
# <p><strong><code>$DEBUG</code></strong> (Default: unset).</p>
# <p><strong><code>Debug messages are not shown if unset.</code></strong></p>
# <p>Activate with either of:</p>
# <ul>
# <li><code>DEBUG=1</code></li>
# <li><code>--debug</code></li>
# </ul>
# </html>
      DEBUG=1
      add=''; content=''; line=''; sep=' '
      sets="$(set +o | tr '\n' ';')"
      set +o nounset  # set +u
      add=""; content=""; suffix=""
      if command -v caller >/dev/null; then
        i=0
        while c="$(caller "${i}")"; do
          if [ "$(echo "${c}" | awk '{ print $2 }')" = 'die' ] \
            || [ "$(basename "$(echo "${c}" | awk '{ print $3 }')")" = 'helpers.lib' ]; then
            i="$((i+1))"
          else
            break
          fi
        done
        file="$(basename "$(echo "${c}" | awk '{ print $3 }')")"
        line="$(echo "${c}" | awk '{ print $1 }')"
      fi

      [ "${file-}" ] || file="$(basename "$(psargs '' | awk '{ print $1 }')" 2>/dev/null || true)"
      [ ! "${file-}" ] || add="$(greyinvert "${file}[${line}]"): "

      for arg do
        content="${content}${suffix}${arg}=$(eval echo "\$${arg}")"
        suffix=", "
      done

      if test -z "${content}" && test "${add}"; then
        add="${add%??}" # if no args, remove trailing ": "
      elif test -z "${content}"; then
        sep=''
      fi

      printf '%b\n' "$(greybold '!')${sep}${add}$(greydim "${content}")" >&2
      eval "${sets}"  # set -u, if it was set before
      unset add arg c content sep sets suffix
    fi
  else
    DESC='Show info message with + symbol in grey bold if DEBUG is set, unless QUIET is set' \
      PARSE='debug' parse "$@"
  fi
}

####################################### ✓|x die: QUIET (default: unset)
# Show message (success or error) with symbol (✓, x respectively) based on status code, unless QUIET is set and exit
# Globals:
#   Green              Green color for ✓ symbol.
#   PARSE              Function name or file.
#                      Default if BASH_VERSION: FUNCNAME[1] if BASH_SOURCE[1] is *.lib, otherwise BASH_SOURCE[1].
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRYRUN (default: unset).
#   Red                Red color for error message and x symbol.
#   Reset              Reset color.
# Arguments:
#   message            Message to show.
#   --man              Show help from man page and exit.
#   --desc             Show description from $DESC or header file comment and exit.
#   --manrepo          Show repository from man page and exit.
#   --vers             Show version from man page and exit.
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
# Note:
#  Do not use command substitution in the message when false || die.
#  Previous error code is overwritten by the command substitution return code.
#  $ cd "$(dirname "${input}")" 2>/dev/null || die Directory not Found: "$(dirname "${input}")"
# Output:
#   Message to stderr if error and stdout for success.
# Returns:
#   1-255 for error, 0 for success.
#######################################
die() {
  rc=$?
  if test "$#" -eq 0 || { test "${1-}" = '--parsed' && shift; }; then
    rc="${firstrc:-${rc}}"
    if test "${QUIET-0}" -ne 1; then
      case "${rc}" in
        0) success "$@" ;;
        *) error "$@" ;;
      esac
    else
# <html><h2>Silent Output</h2>
# <p><strong><code>$QUIET</code></strong> (Default: unset).</p>
# <p><strong><code>The following messages are shown if unset:</code></strong></p>
# <ul>
# <li><code>error</code></li>
# <li><code>success</code></li>
# </ul>
# <p><strong><code>If unset or 0, other messages are shown base on the variable value:</code></strong></p>
# <ul>
# <li><code>debug</code>: $DEBUG</li>
# <li><code>verbose</code>: $VERBOSE</li>
# <li><code>warning</code>: $WARNING</li>
# </ul>
# <p>Activate with either of:</p>
# <ul>
# <li><code>QUIET=1</code></li>
# <li><code>--quiet</code></li>
# </ul>
# <p><strong><code>Note:</code></strong></p>
# <p>Takes precedence over $DEBUG, $VERBOSE and $WARNING.</p>
# </html>
      QUIET=1
    fi
    exit "${rc}"
  else
    # shellcheck disable=SC2034
    firstrc="${rc}"
    DESC="Show message (ok or error) with symbol (✓, x respectively) based on status code, unless QUIET is set \
and exit" PARSE='die' parse "$@"
  fi
}

####################################### x error: QUIET (default: unset)
# Show error message with x symbol in red, unless QUIET is set
# Globals:
#   PARSE              Function name or file.
#                      Default if BASH_VERSION: FUNCNAME[1] if BASH_SOURCE[1] is *.lib, otherwise BASH_SOURCE[1].
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRYRUN (default: unset).
#   Red                Red color for error message and x symbol.
#   Reset              Reset color.
# Arguments:
#   message            Message to show.
#   --man              Show help from man page and exit.
#   --desc             Show description from $DESC or header file comment and exit.
#   --manrepo          Show repository from man page and exit.
#   --vers             Show version from man page and exit.
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
# Output:
#   Message to stderr.
#######################################
error() {
  if test "$#" -eq 0 || { test "${1-}" = '--parsed' && shift; }; then
    if test "${QUIET-0}" -ne 1; then
      add=''; line=''; sep=' '
      if command -v caller >/dev/null; then
        i=0
        while c="$(caller "${i}")"; do
          if [ "$(echo "${c}" | awk '{ print $2 }')" = 'die' ] \
            || [ "$(basename "$(echo "${c}" | awk '{ print $3 }')")" = 'helpers.lib' ]; then
            i="$((i+1))"
          else
            break
          fi
        done
        file="$(basename "$(echo "${c}" | awk '{ print $3 }')")"
        line="$(echo "${c}" | awk '{ print $1 }')"
      fi

      [ "${file-}" ] || file="$(basename "$(psargs '' | awk '{ print $1 }')" 2>/dev/null || true)"
      [ ! "${file-}" ] || add="$(redbg "${file}[${line}]"): "

      if test "$#" -eq 0 && test "${add}"; then
        add="${add%??}" # if no args, remove trailing ": "
      elif test "$#" -eq 0; then
        sep=''
      fi

      if test "${WHITE-}"; then
        test -z "${add}" || printf '%b\n' "$(redbold "x${sep}${add}")" >&2
        test "$#" -eq 0 || echo "$@" >&2
      else
         printf '%b\n' "$(redbold 'x')${sep}${add}$(redbold "$*")" >&2
      fi

      unset add c file line sep
    fi
  else
    DESC="Show error message with x symbol in red, unless QUIET is set" PARSE='error' parse "$@"
  fi
}

####################################### has
# Check if an executable exists.
# Arguments:
#   --all               Find all paths.
#   --bin               The first without /bin/sh shebang (does not work with sudo).
#   --path              Use path (does not have any effect for: '--all' and '--bin', always searches in $PATH).
#   --value             Show value (does not have any effect for: '--all' and '--bin', always shows value).
#   executable          Executable to check (default: sudo if no image and not executable).
#   image               The image name (default: local).
# Common Arguments:
#   --man               Show help from man page and exit.
#   --desc              Show description from $DESC or header file comment and exit.
#   --manrepo           Show repository from man page and exit.
#   --vers              Show version from man page and exit.
# Optional Arguments:
#   --debug             Show debug messages.
#   --dryrun            Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet             Silent output.
#   --verbose           Show verbose messages.
#   --warning           Show warning messages.
# Returns:
#   1 if it does not exist.
#######################################
has() {
  if test "$#" -eq 0 || { test "${1-}" = '--parsed' && shift; }; then
    doc() { docker run -i --rm --entrypoint sh "${image}" -c "${1}"; }

    all=false; bin=false; path=false; value=false
    for arg; do
      case "${arg}" in
        --all) all=true; value=true ;;
        --bin) all=true; bin=true; value=true ;;
        --path) path=true ;;
        --value) value=true ;;
        *)
          if [ "${executable-}" ]; then
            image="${arg}"
          elif [ "${arg:-}" != '' ]; then
            executable="${arg}"
          fi
          ;;
      esac
    done

    executable="${executable:-sudo}"

    if [ "${image-}" ]; then
      docker --version >/dev/null || exit
      if $all; then
        rv="$(doc "which -a ${executable} || type -aP ${executable} || true")"
      elif $path; then
        rv="$(doc "command -v ${executable} | grep -v '^alias ' || true")"
      elif $bin; then
        rv="$(doc "command -vp ${executable} || true")"
      else
        rv="$(doc "command -v ${executable} || true")"
      fi
    else
      if $all; then
        # shellcheck disable=SC3045
        rv="$(which -a "${executable}" || type -aP "${executable}" || true)"
      elif $path; then
        rv="$(command -v "${executable}" | grep -v '^alias ' || true)"
      elif $bin; then
        rv="$(command -vp "${executable}" || true)"
      else
        rv="$(command -v "${executable}" || true)"
      fi
    fi

    if $bin; then
      brew="$(brew --prefix "${executable}" 2>/dev/null || true)"
      if [ "${brew-}" ]; then
        if [ "${rv-}" ]; then
          # shellcheck disable=SC3037
          rv="$(echo -e "${brew}\n${rv}")"
        else
          rv="${brew}"
        fi
      fi
    fi

    if test "${rv-}"; then
      ! $value || echo "${rv}"
    else
      false
    fi
    unset all bin executable image path rv value; unset -f doc
  else
    DESC='Check if an executable exists' PARSE='has' parse "$@"
  fi
}

####################################### parse
# Parse common long optional arguments.
# Globals:
#   PARSE              Function name or file.
#                      Default if BASH_VERSION: FUNCNAME[1] if BASH_SOURCE[1] is *.lib, otherwise BASH_SOURCE[1].
#   POSTPARSE          Variables to unset after each run of a function when parsed.
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRYRUN (default: unset).
#   Red                Red color for error message and x symbol.
#   Reset              Reset color.
# Arguments:
#   -parse             As first argument indicates to parse for itself and expects only one long arguments,
#                      otherwise act as proxy (parse function).
#   --man              Show help from man page and exit (must be the first argument).
#   --desc             Show description from $DESC or header file comment and exit (must be the first argument).
#   --manrepo          Show repository from man page and exit (must be the first argument).
#   --novars           Skip parsing options which generates globals (--debug, etc.)
#                      so they remain for the following command, for instance: bash, sh, sudo etc.
#                      (must be the first argument).
#   --vers             Show version from man page and exit (must be the first argument).
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
#   --white            Multi line error message.
# Output:
#   Message to stderr if error and stdout for success.
# Returns:
#   1-255 for error, 0 for success.
#######################################
# shellcheck disable=SC3028,SC3054
parse() {
  if [ "${1-}" ]; then
    unset arg
    if [ "${#}" -eq 2 ] && [ "${1}" = '-parse' ]; then
      case "${2-}" in --desc|--man|--manrepo|--vers) shift;; esac
# <html><h2>Function one line Description</h2>
# <p><strong><code>$DESC</code></strong> contains the function description, for scripts is automatically extracted.</p>
# <p>Use <strong>$DESC</strong> to call `parse` from a function so it is shown when --desc argument is used.</p>
# <h3>Examples</h3>
# <dl>
# <dt>From a function:</dt>
# <dd>
# <pre><code class="language-bash">DESC='description'
# DESC='Function description' PARSE='function' parse &quot;$@&quot;
# </code></pre>
# </dd>
# </dl>
# </html>
      DESC='Parse common long optional arguments'
# <html><h2>Function Name or Full Script Path to Parse Arguments</h2>
# <p><strong><code>$PARSE</code></strong> contains the function name or script path ($0).</p>
# <p>Use <strong>$PARSE</strong> to call `parse` from a function or script in posix.</p>
# <p>If not set and BASH_VERSION, the following are used: </p>
# <ul>
# <li><code>FUNCNAME[1]: if BASH_SOURCE[1] =~ *.lib</code></li>
# <li><code>BASH_SOURCE[1]: if BASH_SOURCE[1] != *.lib</code></li>
# </ul>
# <h3>Examples</h3>
# <dl>
# <dt>From a function:</dt>
# <dd>
# <pre><code class="language-bash">if test &quot;$#&quot; -eq 0 || { test &quot;${1-}&quot; = '--parsed' && shift; }; then
# &emsp;for arg do; case &quot;${arg}&quot; in --other-option) echo &quot;${arg}&quot; ;; esac; done
# else
# &emsp;DESC='description' PARSE='function' parse &quot;$@&quot;
# fi
# </code></pre>
# </dd>
# </dl>
# <dl>
# <dt>From a library when executed (needs more than one argument):</dt>
# <dd>
# <pre><code class="language-bash">if echo &quot;$0&quot;| grep -q 'name.lib'; then
# &emsp;if test &quot;$#&quot; -ne 0 && test &quot;${1-}&quot; = '--parsed' && shift; then
# &emsp;&emsp;for arg do; case &quot;${arg}&quot; in --other-option) echo &quot;${arg}&quot; ;; esac; done
# &emsp;else
# &emsp;&emsp;PARSE=&quot;$0&quot; parse &quot;$@&quot;
# &emsp;fi
# fi
# </code></pre>
# </dd>
# </dl>
# <dl>
# <dt>From a script in sh:</dt>
# <dd>
# <pre><code class="language-bash">if test &quot;$#&quot; -eq 0 || { test &quot;${1-}&quot; = '--parsed' && shift; }; then
# &emsp;for arg do; case &quot;${arg}&quot; in --other-option) echo &quot;${arg}&quot; ;; esac; done
# else
# &emsp;PARSE=&quot;${0}&quot; parse &quot;$@&quot;
# fi
# </code></pre>
# </dd>
# </dl>
# <dl>
# <dt>From a script in bash:</dt>
# <dd>
# <pre><code class="language-bash">if test &quot;$#&quot; -eq 0 || { test &quot;${1-}&quot; = '--parsed' && shift; }; then
# &emsp;for arg do; case &quot;${arg}&quot; in --other-option) echo &quot;${arg}&quot; ;; esac; done
# else
# &emsp;parse &quot;$@&quot;
# fi
# </code></pre>
# </dd>
# </dl>
# <dl>
# <dt>From a script in which invokes commands to keep the options for the command: bash, sh, etc.:</dt>
# <dd>
# <pre><code class="language-bash">if test &quot;$#&quot; -eq 0 || { test &quot;${1-}&quot; = '--parsed' && shift; }; then
# &emsp;for arg do; case &quot;${arg}&quot; in --other-option) echo &quot;${arg}&quot; ;; esac; done
# else
# &emsp;parse --novars &quot;$@&quot;
# fi
# </code></pre>
# </dd>
# </dl>
# </html>
      PARSE='parse'
    fi

    if [ "${PARSE-}" ]; then
      if echo "${PARSE}" | grep -qE '^/'; then
        path_parse="${PARSE}"
        cmd_parse="$(basename "${path_parse}")"  # script.
      else
        cmd_parse="${PARSE}"
        path_parse="$(command -pv "${cmd_parse}" || false)"  # function: no path.
      fi
    elif [ "${BASH_VERSION-}" ]; then
      if echo "${BASH_SOURCE[1]}" | grep -q '.lib$' ; then
        cmd_parse="${FUNCNAME[1]}"  # function: path.
      else
        cmd_parse="$(basename "${BASH_SOURCE[1]}")"  # script.
      fi
      path_parse="${BASH_SOURCE[1]}"
    fi
    first=true; novars=false; variables_parse=''
    for arg do
      skip=false
      shift
      set +x
      case "${arg}" in
        --noquiet) ! $novars || { variables_parse="${variables_parse} QUIET=0"; skip=true; } ;;
        --novars) ! $first || { novars=true; skip=true; } ;;
        --debug|--dryrun|--quiet|--verbose|--warning|--white)
          if $novars; then
            variables_parse="${variables_parse} $(echo "${arg}" | sed 's/--//' | tr '[:lower:]' '[:upper:]')=1"
            skip=true
          fi
          ;;
        --desc)
          if $first; then
            if [ ! "${DESC-}" ] && [ "${path_parse-}" ]; then
              DESC="$(awk '/^#/ && ! /^#!/ && ! /^##/ && ! /^#$/ && ! /^# shellcheck/ {sub(/^# /, ""); print $0=$0 }' \
                "${path_parse}" | head -1)"
            fi
            [ "${DESC-}" ] || exit
            echo "${DESC}"; exit
          fi
          ;;
         --man|--manrepo|--vers)
          if $first; then
            page="$(man -P cat "${cmd_parse}" 2>/dev/null || true)"
            [ "${page:-}" ] || exit 1
            case "${arg}" in
              --man) echo "${page}" ;;
              --manrepo) echo "${page}" | awk '/^REPOSITORY$/{ getline; print $1 }' ;;
              --vers) echo "${page}" | tail -1 | awk '{ print $2 }' ;;
            esac
            exit
          fi
          ;;
      esac
      first=false
      $skip || set -- "$@" "${arg}"
    done
    unset arg DESC first novars page PARSE skip
    run_parse=${path_parse:-${cmd_parse}}
    test "$(type "${run_parse}")" != 'file' || exec='exec'
    eval "${variables_parse} ${exec:-} ${run_parse} --parsed" "\$@"
    eval_rc=$?
    unset cmd_parse path_parse variables_parse
    if [ "${DRYRUN-}" ]; then
      # <html><h2>Dry Run</h2>
      # <p><strong><code>$DRYRUN</code></strong> (Default: unset).</p>
      # <p>Activate with either of:</p>
      # <ul>
      # <li><code>DRYRUN=1</code></li>
      # <li><code>--dryrun</code></li>
      # </ul>
      # </html>
      DRYRUN=1
    fi
    # FIXME: inline variables in centos sh remain after command: DEBUG=1 debug
    # _f() { if [ "${1-}" ]; then ${path:-${cmd}} "$@"; else ${path:-${cmd}}; fi; }
    # eval "${variables} _f" "\$@"
    return "${eval_rc}" 2>/dev/null || exit "${eval_rc}"
  fi
}

####################################### psargs
# Parent process args (cmd/command and args part of ps) if in a subshell or cmd of the current shell if running in a subshell.
# $$ is defined to return the process ID of the parent in a subshell; from the man page under "Special Parameters":
# expands to the process ID of the shell. In a () subshell, it expands to the process ID of the current shell,
# not the subshell.
# Arguments:
#   --usage             Show help message and exit.
# Outputs:
#   Process (ps) args.
# Returns:
#   1 if error during installation of procps or not know to install ps or --usage and not man page.
# ######################################
psargs() {
  if test "$#" -eq 0 || { test "${1-}" = '--parsed' && shift; }; then
    if command -v ps >/dev/null; then
      if ! ps -p $$ -o args= 2>/dev/null; then
        ps -o pid= -o args= | awk '/$$/ { $1=$1 };1' | grep "^$$ " | cut -d '' -f 2-
      fi
    fi
  else
    DESC='Parent process args (cmd/command and args part of ps)' PARSE='psargs' parse "$@"
  fi
}

####################################### ✓ success: QUIET (default: unset)
# Show success message in white with green ✓ symbol, unless QUIET is set
# Globals:
#   Green              Green color for ✓ symbol.
#   PARSE              Function name or file.
#                      Default if BASH_VERSION: FUNCNAME[1] if BASH_SOURCE[1] is *.lib, otherwise BASH_SOURCE[1].
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRYRUN (default: unset).
#   Reset              Reset color.
# Arguments:
#   message            Message to show.
#   --man              Show help from man page and exit.
#   --desc             Show description from $DESC or header file comment and exit.
#   --manrepo          Show repository from man page and exit.
#   --vers             Show version from man page and exit.
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
# Output:
#   Message to stdout.
#######################################
success() {
  if test "$#" -eq 0 || { test "${1-}" = '--parsed' && shift; }; then
    if test "${QUIET-0}" -ne 1; then
      sep=''
      test "$#" -eq 0 || sep=' '
      printf '%b\n' "$(greenbold '✓')${sep}$*"
      unset sep
    fi
  else
    DESC="Show success message in white with green ✓ symbol, unless QUIET is set" PARSE='success' parse "$@"
  fi
}

####################################### > verbose: VERBOSE (default: unset), QUIET (default: unset)
# Show verbose/dry-run message with > symbol in grey dim if VERBOSE or DRYRUN are set, unless QUIET is set
# Globals:
#   DRYRUN             Show message if set, unless QUIET is set (default: unset).
#   GreyDim            Grey dimmed color for info message and > symbol.
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRYRUN (default: unset).
#   Reset              Reset color.
#   VERBOSE            Shows message if set, unless QUIET is set (default: unset).
# Arguments:
#   message            Message to show.
#   --man              Show help from man page and exit.
#   --desc             Show description from $DESC or header file comment and exit.
#   --manrepo          Show repository from man page and exit.
#   --vers             Show version from man page and exit.
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
# Output:
#   Message to stdout.
#######################################
verbose() {
  if test "$#" -eq 0 || { test "${1-}" = '--parsed' && shift; }; then
    if test "${QUIET-0}" -ne 1 && { test "${VERBOSE-}" || test "${DRYRUN-}"; }; then
# <html><h2>Show Verbose Messages</h2>
        # <p><strong><code>$VERBOSE</code></strong>  (Default: unset).</p>
        # <p><strong><code>Verbose messages are not shown if unset.</code></strong></p>
        # <p>Activate with either of:</p>
        # <ul>
        # <li><code>VERBOSE=1</code></li>
        # <li><code>--verbose</code></li>
        # </ul>
      # </html>
        VERBOSE=1
        sep=''
        test "$#" -eq 0 || sep=' '
        printf '%b\n' "$(cyanbold '>')${sep}$(cyandim "$*")"
        unset sep
    fi
  else
    DESC='Show verbose/dry-run message with > symbol in grey dim if VERBOSE or DRYRUN are set, unless QUIET is set' \
      PARSE='verbose' parse "$@"
  fi
}

####################################### > warning: WARNING (default: unset), QUIET (default: unset)
# Show warning message with ! symbol in yellow if WARNING is set, unless QUIET is set
# Globals:
#   Yellow             Yellow color for warning message and ! symbol.
#   Reset              Reset color.
#   QUIET              Do not show message if set (but 0), takes precedence over VERBOSE/DRYRUN (default: unset).
#   WARNING            Shows message if is set, unless QUIET is set (default: unset).
# Arguments:
#   message            Message to show.
#   --man              Show help from man page and exit.
#   --desc             Show description from $DESC or header file comment and exit.
#   --manrepo          Show repository from man page and exit.
#   --vers             Show version from man page and exit.
# Optional Arguments:
#   --debug            Show debug messages.
#   --dryrun           Show commands that will be executed.
#   --noquiet          Do not silent output for commands which silent error by default (git top, etc.).
#   --quiet            Silent output.
#   --verbose          Show verbose messages.
#   --warning          Show warning messages.
# Output:
#   Message to stderr.
#######################################
warning() {
  if test "$#" -eq 0 || { test "${1-}" = '--parsed' && shift; }; then
     if test "${QUIET-0}" -ne 1 && test "${WARNING-}"; then
# <html><h2>Show Warning Messages</h2>
# <p><strong><code>$WARNING</code></strong>  (Default: unset).</p>
# <p><strong><code>Warning messages are not shown if unset</code></strong></p>
# <p>Activate with either of:</p>
# <ul>
# <li><code>WARNING=1</code></li>
# <li><code>--warning</code></li>
# </ul>
# </html>
        WARNING=1
        add=''; line=''; sep=' '
        if command -v caller >/dev/null; then
          i=0
          while c="$(caller "${i}")"; do
            if [ "$(echo "${c}" | awk '{ print $2 }')" = 'die' ] \
              || [ "$(basename "$(echo "${c}" | awk '{ print $3 }')")" = 'helpers.lib' ]; then
              i="$((i+1))"
            else
              break
            fi
          done
          file="$(basename "$(echo "${c}" | awk '{ print $3 }')")"
          line="$(echo "${c}" | awk '{ print $1 }')"
        fi

        [ "${file-}" ] || file="$(basename "$(psargs '' | awk '{ print $1 }')" 2>/dev/null || true)"
        [ ! "${file-}" ] || add="$(yellowinvert "${file}[${line}]"): "

        if test "$#" -eq 0 && test "${add}"; then
          add="${add%??}" # if no args, remove trailing ": "
        elif test "$#" -eq 0; then
          sep=''
        fi

        printf '%b\n' "$(yellowbold '!')${sep}${add}$(yellowbold "$*")" >&2
        unset add c file line sep
    fi
  else
    DESC='Show warning message with ! symbol in yellow if WARNING is set, unless QUIET is set' \
      PARSE='warning' parse "$@"
  fi
}

####################################### Executed: force & parse
#
if echo "$0" | grep -q 'helpers.lib$'; then
  if test "$#" -ne 0 && test "${1-}" = '--parsed' && shift; then
    case "$1" in
      --force) shift; PROFILE=0 . profile.lib
    esac
  elif test "$#" -ne 0; then
    PARSE="$0" parse "$@"
  fi
fi
