#!/bin/sh

# Prepend (beginning, the default), append (end) or remove to colon variables (PATH, INFOPATH, MANPATH etc.)
#
set -eu

fields=2
# Paths to Add (format: path;UNAME)
#
path="$(command -p cat <<EOF
${RC_PREFIX}/sbin;${UNAME}
${RC_PREFIX}/bin;${UNAME}
${RC_PREFIX}/lib;${UNAME}
${RC_D}/sbin;${UNAME}
${RC_D}/bin;${UNAME}
${RC_D}/lib;${UNAME}
/opt/sbin;${UNAME}
/opt/bin;${UNAME}
${HOMEBREW_PREFIX}/sbin;Linux
${HOMEBREW_PREFIX}/bin;Linux
/usr/local/sbin;${UNAME}
/usr/local/bin;${UNAME}
${CLT}/usr/bin;Darwin
/usr/sbin;${UNAME}
/usr/bin;${UNAME}
/sbin;${UNAME}
/bin;${UNAME}
${PYCHARM:-};Darwin
${PYCHARM_CONTENTS:+${PYCHARM_CONTENTS:+/MacOS}};Darwin
EOF
)"

infopath="$(command -p cat <<EOF
${RC_PREFIX};${UNAME}
${RC_D};${UNAME}
/opt;${UNAME}
${HOMEBREW_PREFIX}/info;Linux
/usr/local/bin/info;${UNAME}
${CLT}/share/info;Darwin
EOF
)"

manpath="$(command -p cat <<EOF
${RC_PREFIX}/share/man;${UNAME}
${RC_D}/share/man;${UNAME}
/opt/share/man;${UNAME}
${HOMEBREW_PREFIX}/share/man;Linux
/usr/local/share/man;${UNAME}
${CLT}/share/man;Darwin
EOF
)"

#######################################
# Prepend script directory and script directory parent with sbin to 'PATH'
# Globals:
#   DIRECTORY         The directory to prepend, append or remove.
#   SCRIPT_BIN        Script directory.
#   VALUE             Path value to manipulate.
# Outputs:
#   Updated path value.
#######################################
dev() {
  APPEND=false; REMOVE=false
  PROJECT_DIR="$(command -p git top 2>/dev/null)"
  if [ "${PROJECT_DIR-}" ]; then
    EXPORT='PROJECT_DIR' output "${PROJECT_DIR}"
    for i in scripts tools lib bin sbin; do
      value="$(DIRECTORY="${PROJECT_DIR}/${i}" VALUE="${value:-${PATH}}" run exists)"
      for d in src tests; do
        value="$(DIRECTORY="${PROJECT_DIR}/${d}/${i}" VALUE="${value:-${PATH}}" run exists)"
      done
    done
    EXPORT='PATH' output "${value}"
    EXPORT='MANPATH' run "${PROJECT_DIR}/share/man"
    EXPORT='INFOPATH' run "${PROJECT_DIR}/share/info"
  fi
}

# TODO: ver si el command -vp me quita el /usr/local y lo quita.
#   asi que mejor instalar el bash y el git como no link y hacer lo de brew/opt si es macos para el path
#   adaptar el has cuando el bin que lo he puesto con command -vp para que mire el brew si es mac.
#  hacer el colon bien del init y meter el CLTs.
# TODO: copiar el CLT de homebrew
# TODO: setenv PATH en macOS y el /etc/environment ?
# TODO: poner el root.lib
# TODO: mover el has a executable.
# TODO: cambiar los sed --hola= por @
# TODO: mover el password file a etc/password.sh y no usar MACOS en wheel
# TODO: ver que hago ahora con el root al cambiar a opt y el profile. primero seria usar el PATH en profile.
#     mover las putas librerías a /etc/lib y ponerlas en path ... para que quiero librerías y no las llamo ejecutables
# TODO: y meto en /etc/bin con funciones que tiene mas lógica y generan el rc.d y en lib las que son lib: constantes,
#  ...
# TODO: lo mas fácil es instalar el repo en /etc directamente, a tomar por culo. y hay un fichero que llama a un
#   ejecutable qu ele dice done esta.... bueno eso ya lo dice el colon para el PATH.
# TODO: instalar entonces solo seria.. el /etc/profile
# TODO: ¿Donde meto el puto .envrc, después del colon --dev
# TODO: Update el generated with write for group y cambiar el grupo ver si git lo mantiene. lo dudo. Y si se cambia
#  también el main group del usuario y el grupo en local lo mantiene git????
# TODO: SOLUCIÓN. PRE-COMMIT CAMBIA TODOS LOS SOURCES Y CORRE UNOS TESTS. importar todas las generated.
init() {
  for i in /etc/paths.d/*; do value="$(run "${i}" "${value:-}")"; done
  tmp="$(command -p mktemp)"
  echo "${path}" | grep "${UNAME}" | tail -r > "${tmp}" || die
  while read -r i; do
    [ "$(echo "${i}" | awk -F ';' '{ print NF-1 }')" -eq "$(( fields-1 ))" ] || echo Incorrect Fields: "${i}"
    value="$(run "${i%";${UNAME}"}" "${value}")"
  done < "${tmp}"
  EXPORT='PATH' output "${value}"
  . "${tmp}"
  echo "${PATH}" | while IFS=':' read -r i; do
    init_info_man "$(echo "${i}" | command -p sed 's|/sbin$|g; s|/bin$|g; s|/lib|g')"
  done
  EXPORT='INFOPATH' output "${infopath}"
  EXPORT='MANPATH' output "${manpath}"
}

init_info_man() {
  infopath="$(run "${1}/share/info" "${infopath:-}")";
  manpath="$(run "${1}/share/man" "${manpath:-}")"
}

#######################################
# Show plain output or with export command
# Globals:
#   EXPORT              Variable name to add export command.
# Arguments:
#   value               Path value to show or add export command.
# Output:
#   value or variable and value with export command.
#######################################
output() {
  if [ "${EXPORT-}" ]; then
    echo "${EXPORT}=${1}; export ${EXPORT}"
  else
    echo "${1}"
  fi
}

#######################################
# Prepend (beginning, the default), append (end) or remove
# Globals:
#   APPEND              Add at the end.
#   EXISTS              Do not add it if the directory does not exist (does not apply to $REMOVE).
#   EXPORT              Variable name to add export command.
#   REMOVE              Remove for the path value.
# Optional Arguments:
#   DIRECTORY           The directory to prepend (default), append (--append) or remove (--remove).
#                       (default: script directory and script directory parent with sbin).
#   VALUE               Path value to manipulate (default: "" if 'DIRECTORY' provided, 'PATH' if no 'DIRECTORY').
# Outputs:
#   Updated path value.
#######################################
run() {
  ! $EXISTS || [ -d "${1-}" ] || ! $REMOVE || { output "${2}"; return 2>/dev/null || exit; }
  case ":${2}:" in
    *:"${1}":*)
      if $REMOVE; then
        output "$(echo "${2}" | command -p sed "s|${1}:||; s|:${1}||; s|${1}||")"
      elif [ "${2-}" ]; then
        output "${2}"
      fi
      ;;
    *)
      if [ "${1:-}" ]; then
        if $APPEND; then
          output "${2:+${2}:}${1}"
        else
          output "${1}${2:+:${2}}"
        fi
      else
        output "${2}"
      fi
    ;;
  esac
}

#######################################
# Prepend (beginning, the default), append (end) or remove to colon variables (PATH, INFOPATH, MANPATH etc.)
# Globals:
#   APPEND              Add at the end.
#   EXISTS              Do not add it if the directory does not exist (does not apply to $REMOVE).
#   EXPORT              Variable name to add export command.
#   REMOVE              Remove for the path value.
# Optional Arguments:
#   --append            Add at the end.
#   --dev               Add project paths.
#   --exists            Do not add it if the directory does not exist (does not apply to $REMOVE).
#   --export=<var name> Show variable name with value and export command for eval (default: 'PATH).
#   --remove            Remove for the path value.
#   DIRECTORY           The directory to prepend (default), append (--append) or remove (--remove).
#                       (default: script directory and script directory parent with sbin).
#   VALUE               Path value to manipulate (default: "" if 'DIRECTORY' provided, 'PATH' if no 'DIRECTORY').
# Note:
#   Generates file to be sourced for the three variables when not arguments are provided.
# Outputs:
#   Updated path value or variable and value with export command.
# Examples:
#   $ colon
#   .../sbin:.../bin:$PATH
#   $ colon --export
#   PATH='.../sbin:.../bin:$PATH'; export PATH
#   $ colon -e
#   PATH='.../sbin:.../bin:$PATH'; export PATH
#   $ colon --base
#   /usr/...
#   $ colon /rc.d "$(colon --base)"
#   /rc.d:/usr/...
#   $ colon --base -e
#   PATH='/usr/...'; export PATH
#   $ color --init
#   PATH='...'; export PATH
#   $ colon /foo
#   foo
#   $ colon /foo -e
#   PATH='foo'; export PATH
#   $ colon /foo --export=PATH
#   PATH='foo'; export PATH
#   $ colon /foo /bar
#   /foo:/bar
#   $ colon /foo /bar --export=MANPATH
#   MANPATH='/foo:/bar'; export MANPATH
#   $ colon /foo /bar --append
#   /bar:/foo
#   $ colon /foo /bar --append --export=INFOPATH
#   INFOPATH='/bar:/foo'; export INFOPATH
#   $ colon --append /foo /bar
#   /bar:/foo
#   $ colon --append /foo /bar --export
#   PATH='/bar:/foo'; export PATH
#   $ colon /foo --remove /bar:/foo
#   /bar
#   $ colon /foo --remove /bar:/foo --export=
#   PATH='/bar'; export PATH
#######################################
main() {
  if [ "$#" -eq 0 ]; then
    init
  elif { test "${1-}" = '--parsed' && shift; }; then
    APPEND=false
    EXISTS=false
    REMOVE=false
    for arg do
      shift
      case "${arg}" in
        --append) APPEND=true ;;
        --exists) EXISTS=true ;;
        --export|--export=) EXPORT='PATH' ;;
        --export=*) EXPORT="${arg#--export=}" ;;
        --remove) REMOVE=true ;;
        --dev) { [ "${DEV:-0}" -eq 1 ] || exit; }; APPEND=false REMOVE=false "${arg}"; exit ;;
      esac
      set -- "$@" "${arg}"
    done
    run "$@"
  else
    PARSE="${0}" parse "$@"
  fi
}

main "$@"
