#!/usr/bin/env bash
#bashsupport disable=BP2002
#
# Perform bootstrap and export helper functions when is sourced.

#######################################
# Show help or description and checks if -v/--verbose, --no-std, --no-stderr or --no-stdout in args
# Globals:
#   BASH_HELP       help (first or second line is description) for function
#   BASH_NO_NEWLINE set to true if --no-newline in arguments, otherwise false
#   BASH_NO_STDERR  set to true if --no-std and--no-stderr in arguments, otherwise false
#   BASH_NO_STDOUT  set to true if --no-std and --no-stdout in arguments, otherwise false
#   BASH_PARAMS     function parameters array $@ without global arguments/options
#   BASH_OPTIONS    array set with global options
#   BASH_SEPARATOR  set to value and space if --separator= in arguments (default: ', ')
#   BASH_VERBOSE    set to true if --v/--verbose in arguments, otherwise false
# Arguments:
#   --no-help       do not show default help for this function if 'BASH_HELP' not set (for functions without 'BASH_HELP'
# Global Arguments:
#   --desc          show description
#   -h, --help      show help
# Global Options:
#   --no-newline    do not add newline in output
#   --no-std        set 'BASH_NO_STDERR' and 'BASH_NO_STDOUT' globals to true and remove --no-std in 'BASH_PARAMS'
#   --no-stderr     set 'BASH_NO_STDERR' global to true and remove --no-stderr in 'BASH_PARAMS'
#   --no-stdout     set 'BASH_NO_STDOUT' global to true and remove --no-stdout in 'BASH_PARAMS'
#   --separator=    separator, space will be added and remove --no-stdout in 'BASH_PARAMS' (default: ',')
#   -v, --verbose   set 'BASH_VERBOSE' global to true and remove -v, --verbose in 'BASH_PARAMS'
# Outputs:
#   Writes help or description to stdout
# Returns:
#   1 if help/desc option passed. Message is printed and command should exit
#######################################
args() {
  local _help
  _help=$(
    cat <<EOF
NAME
  ${FUNCNAME[0]} - Show help or description and checks if -v/--verbose, --no-std, --no-stderr or --no-stdout in args.

SYNOPSIS
  ${FUNCNAME[0]} [-h | --help]
  ${FUNCNAME[0]} [--desc]
  ${FUNCNAME[0]} "${@}"

DESCRIPTION
  Show help message ('-h' or '--help') or first line ('--desc') if 'BASH_HELP' is set (default: for '${FUNCNAME[0]}')
  Set global 'BASH_PARAMS' array without -v, --verbose, --no-std, --no-stderr and --no-stdout
  Set global 'BASH_NO_NEWLINE' to true if '--no-newline' in arguments
  Set global 'BASH_NO_STDERR' to true if '--no-std' or '--no-stderr' in arguments
  Set global 'BASH_NO_STDOUT' to true if '--no-std' or '--no-stdout' in arguments
  Set global 'BASH_OPTIONS' with global options
  Set global 'BASH_SEPARATOR' with separator and space (default: ,)
  Set global 'BASH_VERBOSE' to true if '-v' or '--verbose' in arguments

GLOBALS
  BASH_PARAMS       arguments array without global options/arguments.
  BASH_HELP       help (first or second line is description) for function.
  BASH_NO_STDERR  set to true if --no-stderr in arguments, otherwise false.
  BASH_NO_STDOUT  set to true if --no-stdout in arguments, otherwise false.
  BASH_OPTIONS    array set with global options
  BASH_SEPARATOR  set to value and space if --separator= in arguments (default: ', ')
  BASH_VERBOSE    set if --v/--verbose in arguments.

GLOBAL ARGUMENTS
  -h, --help     Show 'BASH_HELP' if 'BASH_HELP' is set, otherwise help for '${FUNCNAME[0]}'.
  --desc         Show desc from 'BASH_HELP' message if 'BASH_HELP' is set, otherwise desc for '${FUNCNAME[0]}'.
  --no-help      Do not show default '${FUNCNAME[0]}' help if 'BASH_HELP' is not set (for functions without 'BASH_HELP'.
  --no-std       Set 'BASH_NO_STDERR' and 'BASH_NO_STDOUT' globals to true and remove --no-std in 'BASH_PARAMS'.
  --no-stderr    Set 'BASH_NO_STDERR' global to true and remove --no-stderr in 'BASH_PARAMS'.
  --no-stdout    Set 'BASH_NO_STDOUT' global to true and remove --no-stdout in 'BASH_PARAMS'.

$( blue GLOBAL OPTIONS )
  $( green --no-newline )     do not add newline in output (default: false)
  $( green --separator= )     separator, space will be added and remove --no-stdout in 'BASH_PARAMS' (default: ',')
  $( green '-v, --verbose' )  show caller file, function and line number (default: false)

OUTPUTS:
  Writes help or description to stdout.

RETURNS
  1   Help/desc option passed. Message is printed and command should exit.

EXAMPLES
  $ ${FUNCNAME[0]}
  $ ${FUNCNAME[0]}" || return
  $ ${FUNCNAME[0]} a --verbose 'b c'; echo "$? ${BASH_VERBOSE}\n $(printf '%s\n' "${BASH_PARAMS[@]}")"
  1 1
  a
  b c
  $ ${FUNCNAME[0]} --help   # Prints 'help' for '${FUNCNAME[0]}'.
  $ ${FUNCNAME[0]} --desc   # Prints 'desc' for '${FUNCNAME[0]}'.
  $ ${FUNCNAME[0]} "\${@}"  # Prints 'BASH_HELP' or desc from 'BASH_HELP' if '--desc', '-h' or '--help' in '$@'."
EOF
  )
  local desc=false first help=false no=false removed=false rv
  export BASH_PARAMS=() BASH_NO_NEWLINE=false BASH_NO_STDERR=false BASH_NO_STDOUT=false BASH_OPTIONS=() \
    BASH_SEPARATOR=', ' BASH_VERBOSE=false
  if [[ "$#" -ge 1 ]]; then
    while (( "${#}" )); do
      case "${1}" in
        -h|--help) help=true ;;
        -v|--verbose) BASH_VERBOSE=true; removed=true ;;
        --desc) desc=true ;;
        --no-help) no=true ;;
        --no-newline) BASH_NO_NEWLINE=true; removed=true ;;
        --no-std)
          BASH_NO_STDERR=true
          BASH_NO_STDOUT=true
          removed=true
          ;;
        --no-stderr) BASH_NO_STDERR=true; removed=true ;;
        --no-stdout) BASH_NO_STDOUT=true; removed=true ;;
        --separator=*) BASH_SEPARATOR="${1#--separator=} "; removed=true ;;
        *) BASH_PARAMS+=( "${1}" ) ;;
      esac
      if $removed; then
        BASH_OPTIONS+=( "${1}" )
        removed=false
      fi
      shift
    done
    if $no && test -n "${BASH_HELP}"; then
      return
    fi
    if $help || $desc; then
      if test -n "${BASH_HELP}"; then
        rv=1
      else
        BASH_HELP="${_help}"
      fi
      if $desc; then
        first="$(sed -n 1p <<<"${BASH_HELP}")"
        [[ "${first}" != 'NAME' ]] && BASH_HELP="${first}" || BASH_HELP="$(sed -n 2p <<<"${BASH_HELP}")"
        # Trim leading/trailing space or tab characters and also squeeze sequences of tabs and spaces into a single space.
        BASH_HELP="$(awk '{$1=$1};1' <<<"${BASH_HELP}")"
      fi
      cat <<EOF
${BASH_HELP}
EOF
      unset BASH_HELP
      return $rv
    fi
  fi
}

#######################################
# Caller file, func and line number based on caller stack index (default: 1)
# Globals:
#   BASH_PARAMS       arguments array without -v/--verbose, --no-std, --no-stderr and --no-stdout
#   BASH_HELP       help (with description) for function
#   BASH_NO_NEWLINE set to true if --no-newline in arguments, otherwise false.
#   BASH_NO_STDOUT  set to true if --no-std and --no-stdout in arguments, otherwise false
#   BASH_RV         associated array with return value, keys; 'file', 'func' and 'line'
#   BASH_SEPARATOR  set to value and space if --separator= in arguments (default: ', ')
# Arguments:
#   index           caller stack index (default: 2)
#   --desc          show description
#   -h, --help      show help
# Options:
#   --no-newline    do not add newline in output
#   --no-std        do not show 'file', 'func' and 'line'
#   --no-stdout     do not show 'file', 'func' and 'line'
#   --separator=    separator, space will be added and remove --no-stdout in 'BASH_PARAMS' (default: ',')
# Output:
#   Sets global 'BASH_RV' associated array with: 'file', 'func' and 'line' or writes to stderr
# ######################################
called() {
  BASH_HELP=$(
    cat <<EOF
$( blue NAME )
  $( green "${FUNCNAME[0]}" ) - caller file, func and line number based on caller stack index (default: 2)

$( blue SYNOPSIS )
  $( green "${FUNCNAME[0]}" )
  $( green "${FUNCNAME[0]}" ) 1
  $( green "${FUNCNAME[0]}" ) 1 [--no-newline] [--no-std|--no-stdout] [--separator=<value>]

$( blue DESCRIPTION )
  Caller file, func and line number based on caller stack index (default: 2)

$( blue GLOBALS )
  $( green BASH_PARAMS )        arguments array without -v/--verbose, --no-std, --no-stderr and --no-stdout
  $( green BASH_HELP )        help (with description) for function
  $( green BASH_NO_NEWLINE )  do not add newline in output
  $( green BASH_SEPARATOR )   set to value and space if --separator= in arguments (default: ', ')
  $( green BASH_NO_STDOUT )   set to true if --no-std and --no-stdout in arguments, otherwise false
  $( green BASH_RV )          associated array with return value, keys; 'file', 'func' and 'line'

$( blue ARGUMENTS )
  $( green index )            caller stack index (default: 2)
  $( green --desc )           show description
  $( green '-h, --help' )       show help

$( blue OPTIONS )
  $( green --no-newline )     do not add newline in output (default: new line at the end)
  $( green --no-std )         do not show 'file', 'func' and 'line'
  $( green --no-stdout )      do not show 'file', 'func' and 'line'
  $( green --separator= )     separator, space will be added and remove --no-stdout in 'BASH_PARAMS' (default: ',')

$( blue OUTPUTS )
  Sets global 'BASH_RV' associated array with: 'file', 'func' and 'line' or writes to stderr (no new line)

$( blue EXAMPLES )
  $( green '$' 0 ) rojo(){ $( cyan "${FUNCNAME[0]} --no-std" ); \
echo "\$(tput setaf 1)\${BASH_RV[func]}\$(tput sgr0)"; }; color_my_name() { rojo; }; color_my_name
  $( tput setaf 1)color_my_name$( tput sgr0 )
  $( green '$' 0 ) who_call_me(){ $( cyan "${FUNCNAME[0]}" ); }; i_called_you() { who_call_me; }; i_called_you
  $( grey file ): $( orange main ), $( grey func ): $( orange i_called_you ), $( grey line ): $( orange 1 )
  $( green '$' 0 ) who_am_i() { $( cyan "${FUNCNAME[0]} 1" ); }; who_am_i
  $( grey file ): $( orange main ), $( grey func ): $( orange who_am_i ), $( grey line ): $( orange 2 )
  $( green '$' 0 ) who_am_i() { $( cyan "${FUNCNAME[0]} 1 --separator=' |'" ); }; who_am_i
  $( grey file ): $( orange main ) | $( grey func ): $( orange who_am_i ) | $( grey line ): $( orange 2 )
  $( green '$' 0 ) main_is_calling_me() { $( cyan "${FUNCNAME[0]} --no-newline" ); }; main_is_calling_me; echo
  $( grey file ): $( orange '<NULL>' ), $( grey func ): $( orange '<NULL>' ), $( grey line ): $( orange '<NULL>' )
EOF
  )
  args "${@}" || return
  unset BASH_RV
  local first=true index key order separator
  index=${BASH_PARAMS[0]:-2}
  # https://stackoverflow.com/questions/60396504/why-dont-bash-associative-arrays-maintain-index-order
  order=( "file" "func" "line" )
  declare -Axg BASH_RV=( ["${order[0]}"]="${BASH_SOURCE[${index}]:-<NULL>}"  \
    ["${order[1]}"]="${FUNCNAME[${index}]:-<NULL>}" ["${order[2]}"]="${BASH_LINENO[${index}]:-<NULL>}" )
  if ! $BASH_NO_STDOUT; then
    for key in "${order[@]}"; do
      $first && first=false || separator="${BASH_SEPARATOR}"
      >&2 echo -n "${separator}$( grey "${key}" ): $( orange "${BASH_RV[${key}]}" )"
    done
    if ! $BASH_NO_NEWLINE; then
      >&2 echo
    fi
  fi
}

#######################################
# Run command and catches return code, stderr and stdout in 'BASH_RC', 'BASH_STDERR', 'BASH_STDOUT'.
# Globals:
#   BASH_PARAMS       Arguments array without -v/--verbose.
#   BASH_HELP       Help (with description) for function.
#   BASH_RC         Caught return code of executed command.
#   BASH_STDIN      Array with caught stdin (args/executed command).
#   BASH_STDERR     Caught stderr of executed command.
#   BASH_STDOUT     Caught stdout of executed command.
#   BASH_VERBOSE    Set to true if --v/--verbose in arguments, otherwise false.
# Arguments:
#   -h, --help      Show help.
#   -v, --verbose   Set global 'BASH_PARAMS' array (without -v, --verbose) and 'BASH_VERBOSE'.
#   --desc          Show description.
# Outputs:
#   Writes help or description to stdout.
#   Writes 'No command' to stderr.
#######################################
catch() {
  : "${1?$(error "${FUNCNAME[0]}" "No command.")}"
  BASH_HELP=$(
    cat <<EOF
NAME
  ${FUNCNAME[0]} - Run command and catches return code, stderr and stdout in 'BASH_RC', 'BASH_STDERR', 'BASH_STDOUT'.

SYNOPSIS
  ${FUNCNAME[0]} command [arg1, arg2, ...]
  ${FUNCNAME[0]} command --help
  ${FUNCNAME[0]} command --verbose [arg1, arg2, ...]

DESCRIPTION
  Run command and catches return code, stderr and stdout in 'BASH_RC', 'BASH_STDERR', 'BASH_STDOUT'.
  Command executed (args) are caught in 'BASH_STDIN' array.

GLOBALS
  BASH_PARAMS       Arguments array without -v/--verbose.
  BASH_HELP       Help (with description) for function.
  BASH_RC         Caught return code of executed command.
  BASH_STDIN      Array with caught stdin (args/executed command).
  BASH_STDERR     Caught stderr of executed command.
  BASH_STDOUT     Caught stdout of executed command.
  BASH_VERBOSE    Set to true if --v/--verbose in arguments, otherwise false.

ARGUMENTS
  -h, --help      Show help.
  -v, --verbose   Verbose.
  --desc          Show description.

OUTPUTS:
  Writes help or description to stdout.
  Writes 'No command' to stderr.

EXAMPLES
  $ ${FUNCNAME[0]} ls --fail
  $ echo \$?; echo "\${BASH_RC}"; printf '%\n' "\${BASH_STDIN[@]}"; echo "\${BASH_STDERR}"; echo "'\${BASH_STDOUT}'"
  1
  1
  ls
  --fail
  ls: illegal option -- -
  usage: ls [-@ABCFGHLOPRSTUWabcdefghiklmnopqrstuwx1%] [file ...]
  ''
  $ ${FUNCNAME[0]} true
  $ echo \$?; echo "\${BASH_RC}"; printf '%\n' "\${BASH_STDIN[@]}"; echo "\${BASH_STDERR}"; echo "'\${BASH_STDOUT}'"
  0
  true
  ''
  ''
  $ ${FUNCNAME[0]} true --help
  $ echo \$?; echo "\${BASH_RC}"; printf '%\n' "\${BASH_STDIN[@]}"; echo "\${BASH_STDERR}"; echo "'\${BASH_STDOUT}'"
  $ ${FUNCNAME[0]} true a --verbose 'b c'
  $ echo \$?; echo "\${BASH_RC}"; printf '%\n' "\${BASH_STDIN[@]}"; echo "\${BASH_STDERR}"; echo "'\${BASH_STDOUT}'"
  $ ${FUNCNAME[0]} false a --verbose 'b c'
  $ echo \$?; echo "\${BASH_RC}"; printf '%\n' "\${BASH_STDIN[@]}"; echo "\${BASH_STDERR}"; echo "'\${BASH_STDOUT}'"

EOF
  )
  local args cmd rc stdout
  export BASH_STDIN=("${@}")
  unset BASH_RC BASH_STDERR BASH_STDOUT
  if [[ "${1-}" ]]; then
    exec 3>&1                                    # Save the place that stdout (1) points to.
    args=("${@:${2:-1}}")                        # Remove "command" for args.
    BASH_STDERR="$(args "${args[@]}" 2>&1 1>&3)" # Check args. stderr is caught. 'BASH_PARAMS'/'BASH_VERBOSE' are set.
    BASH_RC=$?                                   # Catch $?.
    BASH_STDOUT=$(<&3)                           # Catch stdout.
    exec 3>&-                                    # Close FD #3.

    exec 3>&1                                           # Save the place that stdout (1) points to.
    cmd="${1}"                                          # Save command.
    BASH_STDERR="$(${cmd} "${BASH_PARAMS[@]}" 2>&1 1>&3)" # Run command with new args. stderr is caught.
    BASH_RC=$?                                          # Catch $?.
    BASH_STDOUT=$(<&3)                                  # Catch stdout.
    exec 3>&-                                           # Close FD #3.

    args "${args[@]}"
    args "${args[@]}" || return 1
    BASH_STDERR=$("${@}" 2>&1 1>&3) # Run command.  stderr is captured.
    rc="$(args "${args[@]}")"

  fi
}

#######################################
# Show names (default) or descriptions or export functions in file.
# Globals:
#   BASH_HELP
# Arguments:
#   --descriptions        Show functions and descriptions.
#   --export              Export functions.
#   --file=<filepath>     File path (default: file containing this function).
#   --exclude=<functions> Functions to exclude from export or print (default: 'main').
#   -h, --help     Show help.
#   --desc         Show description.
# Outputs:
#   Writes function descriptions or names to stdout.
# ######################################
filefuncs() {
  # TODO: add files more than one y color.
  BASH_HELP=$(
    cat <<EOF
NAME
  ${FUNCNAME[0]} - Show names (default) or descriptions or export functions in file.

SYNOPSIS
  ${FUNCNAME[0]}  (Show function names in file containing this function '${BASH_SOURCE[0]}')
  ${FUNCNAME[0]}  --file=<filepath>
  ${FUNCNAME[0]}  --export
  ${FUNCNAME[0]}  --export --file=<filepath>
  ${FUNCNAME[0]}  --descriptions --file=<filepath> --exclude="funcname1 funcname2"

DESCRIPTION
  Show names (default) or descriptions or export functions in file.

ARGUMENTS
  --descriptions        Show functions and descriptions.
  --export              Export functions.
  --file=<filepath>     File path (default: file containing this function).
  --exclude=<functions> Functions to exclude from export or print (default: 'main').
  -h, --help            Show help.
  --desc                Show description.

OUTPUTS:
  Writes function descriptions or names to stdout.

EXAMPLES
  $ ${FUNCNAME[0]}
  $ ${FUNCNAME[0]} --export
  $ ${FUNCNAME[0]} --descriptions
  $ ${FUNCNAME[0]} --descriptions --exclude='${FUNCNAME[0]}'
  $ ${FUNCNAME[0]} --file=${BASH_SOURCE[0]}
  $ ${FUNCNAME[0]} --export --file=${BASH_SOURCE[0]}
  $ ${FUNCNAME[0]} 0
EOF
  )
  args "${@}" || return
  local descriptions=false exclude exp=false file function functions or rv
  for arg; do
    case "${arg}" in
      --descriptions) descriptions=true ;;
      --export) exp=true ;;
      --file=) file="${arg#--file=}" ;;
      --exclude=) exclude="${arg#--exclude=}" ;;
    esac
    shift
  done
  readarray -t functions < <(grep -o '^[a-z,A-Z]*(' "${file:-${BASH_SOURCE[0]}}" | sed 's/(.*//g')
  or="$(to-or "${exclude}" "main")"
  for function in "${functions[@]}"; do
    if [[ ! "${function}" =~ ${or} ]]; then
      if $exp; then
        # bashsupport disable=BP2001
        export -f "${function?}"
      else
        if $descriptions; then
          function="$(${function} --desc)"
        fi
        rv+=("${function}")
      fi
    fi
  done
  if $exp; then
    return
  else
    printf '%s\n' "${rv[@]}"
  fi
}

#######################################
# Finds up first path that exists and shows 'owner:group'.
# Globals:
#   BASH_HELP       Help (with description) for function.
#   SUDOC           'sudo' path.
# Arguments:
#   path            Path to search up for first existing file/dir.
#   -i, --id        ID instead of owner/group name.
#   -s, --sudo      Show `sudo -u owner`.
#   -h, --help      Show help.
#   --desc          Show description.
# Outputs:
#   Writes 'owner:group' to stdout.
#   Writes 'No path' to stderr.
# ######################################
findup() {
  : "${1?$(error "${FUNCNAME[0]}" "No path.")}"
  BASH_HELP=$(
    cat <<EOF
NAME
  ${FUNCNAME[0]} - Finds up first path that exists and shows 'owner:group'.

SYNOPSIS
  ${FUNCNAME[0]} path

DESCRIPTION
  Finds up first path that exists and shows 'owner:group'.

ARGUMENTS
  path            Path to search up for first existing file/dir.
  -h, --help      Show help.
  --desc          Show description.

OUTPUTS:
  Writes 'owner:group' to stdout.
  Writes 'No path' to stderr.

RETURNS
  1   No arguments.

EXAMPLES
  $ ${FUNCNAME[0]}
  $ ${FUNCNAME[0]} 0
  ^0$
  $ ${FUNCNAME[0]} '0 0'
  ^0 0$
  $ ${FUNCNAME[0]} 0 '1 1' 2
  ^0$|^1 1$|^2
  $ one="1\n1"; ${FUNCNAME[0]} 0 "\${one}" 2
  ^0$|^1 1$|^2
  $ one="1\n1\n"; ${FUNCNAME[0]} 0 "\${one}" 2
  ^0$|^1 1$|^2
EOF
  )
  args "${@}" || return

  local id=false start_dir sudo=false pattern path
  # https://unix.stackexchange.com/questions/6463/find-searching-in-parent-directories-instead-of-subdirectories
  ## findup some_dir -iname "pattern" -execdir start_dir \;
  ## some_dir: print the names of all of some_dir's ancestors (including itself) up to / in which a file with:
  ## pattern: is found (Default: .env), starting from:
  ## start_dir:

  for arg; do
    case "${arg}" in
      --id | -i) id=true ;;
      --sudo | -s) sudo=false ;;
      *) [[ "${arg:0:1}" == "/" ]] && path="${arg}" || path="$(pwd)/${arg}" ;;
    esac
    shift
  done
  if ! test -e "${path}"; then
    while [[ "${path}" != "" && ! -e "${path}/${pattern}" ]]; do
      path=${path%/*}
    done
  fi
  id -un
  whoami
  # macos
  stat -f "%Sp -> owner=%SHp group=%SMp other=%SLp" .
  -n -s
  -T
  -p
  u g
  Y target
  if [[ "${SUDOC-}" ]]; then
    echo "${rv}" -u "${SUDO_USER:-${USER}}"
  fi

  start_dir="${1:-.}"
  pattern="${2:-.env}"

  if [[ -d "${start_dir}" ]]; then
    path="${start_dir}"
  else
    echo "- Error: start_dir: ${start_dir:-''}, does not exist"
    return 1
  fi

  while [[ "${path}" != "" && ! -e "${path}/${pattern}" ]]; do
    path=${path%/*}
  done
  if [[ "${path:-}" ]]; then
    echo "${path}"
  else
    echo "- Error: .env file not found" >&2
    return 1
  fi
}

#######################################
# Finds up first path that exists.
# Globals:
#   BASH_HELP      Help (with description) for function.
# Arguments:
#   path           Path to search up for first existing file/dir.
#   -i, --id       ID instead of owner/group name.
#   -s, --sudo     Show `sudo -u owner`.
#   -h, --help     Show help.
#   --desc         Show description.
# Outputs:
#   Writes firs path found up to stdout.
#   Writes 'No path' to stderr.
# Returns:
#   1 if no path.
# ######################################
firstexists() {
  : "${1?$(error "${FUNCNAME[0]}" "No path.")}"

  BASH_HELP=$(
    cat <<EOF
NAME
  ${FUNCNAME[0]} - Finds up first path that exists and shows 'owner:group'.

SYNOPSIS
  ${FUNCNAME[0]} path

DESCRIPTION
  Finds up first path that exists and shows 'owner:group'.

ARGUMENTS
  path            Path to search up for first existing file/dir.
  -h, --help      Show help.
  --desc          Show description.

OUTPUTS:
  Writes 'No arguments' to stderr.

RETURNS
  1   No arguments.

EXAMPLES
  $ ${FUNCNAME[0]}
  $ ${FUNCNAME[0]} 0
  ^0$
  $ ${FUNCNAME[0]} '0 0'
  ^0 0$
  $ ${FUNCNAME[0]} 0 '1 1' 2
  ^0$|^1 1$|^2
  $ one="1\n1"; ${FUNCNAME[0]} 0 "\${one}" 2
  ^0$|^1 1$|^2
  $ one="1\n1\n"; ${FUNCNAME[0]} 0 "\${one}" 2
  ^0$|^1 1$|^2
EOF
  )
  args "${@}" || return

  local id=false start_dir sudo=false pattern path
  # https://unix.stackexchange.com/questions/6463/find-searching-in-parent-directories-instead-of-subdirectories
  ## findup some_dir -iname "pattern" -execdir start_dir \;
  ## some_dir: print the names of all of some_dir's ancestors (including itself) up to / in which a file with:
  ## pattern: is found (Default: .env), starting from:
  ## start_dir:

  for arg; do
    case "${arg}" in
      --id | -i) id=true ;;
      --sudo | -s) sudo=false ;;
      *) [[ "${arg:0:1}" == "/" ]] && path="${arg}" || path="$(pwd)/${arg}" ;;
    esac
    shift
  done
  if ! test -e "${path}"; then
    while [[ "${path}" != "" && ! -e "${path}/${pattern}" ]]; do
      path=${path%/*}
    done
  fi
  id -un
  whoami
  stat -f "%Sp -> owner=%SHp group=%SMp other=%SLp" .
  -n -s
  -T
  -p
  u g
  Y target
  if [[ "${SUDOC-}" ]]; then
    echo "${rv}" -u "${SUDO_USER:-${USER}}"
  fi

  start_dir="${1:-.}"
  pattern="${2:-.env}"

  if [[ -d "${start_dir}" ]]; then
    path="${start_dir}"
  else
    echo "- Error: start_dir: ${start_dir:-''}, does not exist"
    return 1
  fi

  while [[ "${path}" != "" && ! -e "${path}/${pattern}" ]]; do
    path=${path%/*}
  done
  if [[ "${path:-}" ]]; then
    echo "${path}"
  else
    echo "- Error: .env file not found" >&2
    return 1
  fi
}

#######################################
# Update system gitconfig.
# Globals:
#   BASH_HELP      Help (with description) for function.
# Arguments:
#   -h, --help     Show help.
#   --desc         Show description.
#######################################
gitconfig() {
  BASH_HELP=$(
    cat <<EOF
NAME
  ${FUNCNAME[0]} - Update system gitconfig.

SYNOPSIS
  ${FUNCNAME[0]}

DESCRIPTION
  Update system gitconfig.

ARGUMENTS
  -h, --help      Show help.
  --desc          Show description.
EOF
  )
  args "${@}" || return
  git
}

parent() {
  # No da error y devolvería /
  local path rv
  path="${1:-BASH_SOURCE[0]}"
  if rv=$( resolve "${path}" 2>/dev/null); then
    rv="${rv%/*}"
  else
    path="${path%/*}"
    if [[ "${path}" != "/" ]] && ! rv=$( resolve "${path}" 2>/dev/null ) && [[ "${path:0:1}" != "/" ]]; then
      rv="$(pwd)/${path}"
    fi
  fi
  echo "${rv:-${path}}"
}

resolve() {
  # Realpath resolving symlink
  local cmd
  if cmd="$( command -v realpath 2>/dev/null )"; then
    ${cmd} "${@:-${BASH_SOURCE[0]}}"
  else
    python -c "import os; print(os.path.realpath('${1:-${BASH_SOURCE[0]}}'))"
  fi
}

#######################################
# Have I been sourced?.
# Arguments:
#   -h, --help     Show help.
#   --desc         Show description.
# Returns:
#   0   Sourced.
#   1   Executed.
#######################################
sourced() {
  BASH_HELP=$(
    cat <<EOF
NAME
  ${FUNCNAME[0]} - Have I been sourced?.

SYNOPSIS
  ${FUNCNAME[0]}

DESCRIPTION
  Have I been sourced?.

ARGUMENTS
  -h, --help      Show help.
  --desc          Show description.

RETURNS
  0   Sourced.
  1   Executed.

EXAMPLES
  $ ${FUNCNAME[0]}
  1
  $ f() { ${FUNCNAME[0]}; }; f; echo \$?
  0
EOF
  )
  args "${@}" || return
  if ((${BASH_LINENO[1]:-0} == 0)); then
    return 1
  fi
}

#######################################
# Stack, func and line number.
# Globals:
#   BASH_HELP      Help (with description) for function.
#   BASH_RV        Array with callers: 'file': 1, 'func': 2 and 'line': 3.
# Arguments:
#   -h, --help     Show help.
#   --desc         Show description.
# Output:
#   Sets global 'BASH_RV' array with callers. Each caller item: 'file': 1, 'func': 2 and 'line': 3.
# ######################################
stack() {
  BASH_HELP=$(
    cat <<EOF
NAME
  ${FUNCNAME[0]} - Stack, func and line number.

SYNOPSIS
  ${FUNCNAME[0]}

DESCRIPTION
  Stack, func and line number.

GLOBALS
  BASH_RV      Array with callers: 'file': 1, 'func': 2 and 'line': 3.

ARGUMENTS
  -h, --help    Show help.
  --desc        Show description.

OUTPUTS:
  Sets global 'BASH_RV' array with callers. Each caller item: 'file': 1, 'func': 2 and 'line': 3.

EXAMPLES
  $ ${FUNCNAME[0]}
EOF
  )
  args "${@}" || return

  local stack_size=${#FUNCNAME[@]}
  unset BASH_RV
  # bashsupport disable=BP2001
  declare -xga BASH_RV

  for ((i = 1; i < stack_size; i++)); do
    eval "BASH_RV[((i-1))]"='"${BASH_SOURCE[$i]:-<NULL>} ${FUNCNAME[$i]:-<NULL>} ${BASH_LINENO[$i]}"'
  done
}

#######################################
# Stat file/dir field info for Linux and Darwin.
# Globals:
#   BASH_HELP      Help (with description) for function.
# Arguments:
#   path           Path to search up for first existing file/dir.
#   -i, --id       ID instead of name.
#   -s, --sudo     Show `sudo -u owner`.
#   -h, --help     Show help.
#   --desc         Show description.
# Outputs:
#   Writes file/dir field info to stdout.
#   Writes 'No path' to stderr.
# Returns:
#   1 if no path.
# ######################################
statinfo() {
  : "${1?$(error "${FUNCNAME[0]}" "No path.")}"

  BASH_HELP=$(
    cat <<EOF
NAME
  ${FUNCNAME[0]} - Stat file/dir field info for Linux and Darwin.

SYNOPSIS
  ${FUNCNAME[0]} arg1 arg2 ...

DESCRIPTION
  Convert arguments to regexp OR (^arg1$|^arg2$).

ARGUMENTS
  arg1 arg2 ...   Strings to convert to ^arg1$|^arg2$.
  -h, --help      Show help.
  --desc          Show description.

OUTPUTS:
  Writes 'No arguments' to stderr.

RETURNS
  1   No arguments.

EXAMPLES
  $ ${FUNCNAME[0]}
  $ ${FUNCNAME[0]} 0
  ^0$
  $ ${FUNCNAME[0]} '0 0'
  ^0 0$
  $ ${FUNCNAME[0]} 0 '1 1' 2
  ^0$|^1 1$|^2
  $ one="1\n1"; ${FUNCNAME[0]} 0 "\${one}" 2
  ^0$|^1 1$|^2
  $ one="1\n1\n"; ${FUNCNAME[0]} 0 "\${one}" 2
  ^0$|^1 1$|^2
EOF
  )
  args "${@}" || return

  for arg; do
    case "${arg}" in
      --id | -i) id=true ;;
      --sudo | -s) sudo=false ;;
      *) [[ "${arg:0:1}" == "/" ]] && path="${arg}" || path="$(pwd)/${arg}" ;;
    esac
    shift
  done
}

#######################################
# Shows 'sudo' path if .
# Globals:
#   BASH_HELP      Help (with description) for function.
# Arguments:
#   -h, --help     Show help.
#   --desc         Show description.
# Outputs:
#   Writes `sudo -u user` to stdout.
#######################################
sudoc() {
  command -v sudo
  local rv
  if rv="$(command -v sudo)"; then
    echo "${rv}" -u "${SUDO_USER:-${USER}}"
  fi
}

#######################################
# Convert arguments to regexp OR (^arg1$|^arg2$).
# Globals:
#   BASH_HELP      Help (with description) for function.
# Arguments:
#   arg1 arg2 ...  Strings to convert to ^arg1$|^arg2$.
#   -h, --help     Show help.
#   --desc         Show description.
# Outputs:
#   Writes 'No arguments' to stderr.
# Returns:
#   1 if no arguments.
#######################################
to-or() {
  : "${1?$(error "${FUNCNAME[0]}" "No arguments.")}"
  local add args i last len

  BASH_HELP=$(
    cat <<EOF
NAME
  ${FUNCNAME[0]} - Convert arguments to regexp OR (^arg1$|^arg2$).

SYNOPSIS
  ${FUNCNAME[0]} arg1 arg2 ...

DESCRIPTION
  Convert arguments to regexp OR (^arg1$|^arg2$).

ARGUMENTS
  arg1 arg2 ...   Strings to convert to ^arg1$|^arg2$.
  -h, --help      Show help.
  --desc          Show description.

OUTPUTS:
  Writes 'No arguments' to stderr.

RETURNS
  1   No arguments.

EXAMPLES
  $ ${FUNCNAME[0]}
  $ ${FUNCNAME[0]} 0
  ^0$
  $ ${FUNCNAME[0]} '0 0'
  ^0 0$
  $ ${FUNCNAME[0]} 0 '1 1' 2
  ^0$|^1 1$|^2
  $ one="1\n1"; ${FUNCNAME[0]} 0 "\${one}" 2
  ^0$|^1 1$|^2
  $ one="1\n1\n"; ${FUNCNAME[0]} 0 "\${one}" 2
  ^0$|^1 1$|^2
EOF
  )
  args "${@}" || return

  if [[ ${1-} ]]; then
    add="|"
    args=("${@:1}")
    len="${#args[@]}"
    last=$((len - 1))
    for ((i = 0; i < "${len}"; i++)); do
      if [[ "${i}" -eq "${last}" ]]; then
        unset add
      fi
      # shellcheck disable=SC2116,SC2086
      args[i]="^$(echo ${args[i]})\$${add}"
    done
    printf '%s' "${args[@]}"
  fi
}
# TODO: los nombres de las funciones. https://superuser.com/questions/1111219/can-i-get-all-functions-in-a-script-file-using-bash/1117642
# TODO: test el NAME con los colores si lo encuentra.
# TODO: ver como hago para imprimir las descriptions con color.
# TODO: seguir con el completion y probarlo en las que he hecho.
# TODO: ¿Por que quería lo de los usuarios que están login, seria para ver el grupo?

#######################################
# Shows arguments variable names/values if 'DEBUG_BASH' is set (variables in arguments must be global).
# Globals:
#   BASH_PARAMS       arguments array without -v/--verbose, --no-std, --no-stderr and --no-stdout
#   BASH_HELP       help (with description) for function
#   BASH_NO_NEWLINE set to true if --no-newline in arguments, otherwise false
#   BASH_OPTIONS    array set with global options
#   BASH_SEPARATOR  set to value and space if --separator= in arguments (default: ', ')
#   BASH_VERBOSE    set to true if --v/--verbose in arguments, otherwise false
#   DEBUG_BASH      must be set and exported to show 'name: value' for arguments
# Arguments:
#   var1, var2 ...  variable names to show values (must be exported).
#   --desc          show description.
#   -h, --help      show help.
#   --no-newline    do not add newline in output
#   --separator=    separator, space will be added and remove --no-stdout in 'BASH_PARAMS' (default: ',')
#   -v, --verbose   show caller file, function and line number.
# Outputs:
#   Writes 'name: value' or 'name: value, file: filename, function: funcmane, line: lineno' to stderr.
#######################################
debug() {
  BASH_HELP=$(
    cat <<EOF
$( blue NAME )
  $( green "${FUNCNAME[0]}" ) - shows arguments variable names/values if 'DEBUG_BASH' is set (variables in arguments \
must be global)

$( blue SYNOPSIS )
  $( green "${FUNCNAME[0]}" ) [var1 [var2] [...]] [--no-newline] [--separator=<value>] [-v, --verbose]

$( blue DESCRIPTION )
  Shows arguments variable names/values if 'DEBUG_BASH' is set (variables in arguments must be global)

$( blue GLOBALS )
  $( green BASH_PARAMS )        arguments array without -v/--verbose, --no-std, --no-stderr and --no-stdout
  $( green BASH_HELP )        help (with description) for function
  $( green BASH_NO_NEWLINE )  do not add newline in output
  $( green BASH_SEPARATOR )   set to value and space if --separator= in arguments (default: ', ')
  $( green BASH_VERBOSE )     set to true if --v/--verbose in arguments, otherwise false
  $( green DEBUG_BASH )       must be set and exported to show 'name: value' for arguments

$( blue ARGUMENTS )
  $( green 'var1 var2 ...' )  variable names to show values (must be exported)
  $( green --desc )           show description.
  $( green '-h, --help' )     show help.

$( blue OPTIONS )
  $( green --no-newline )     do not add newline in output (default: new line at the end)
  $( green --separator= )     separator, space will be added and remove --no-stdout in 'BASH_PARAMS' (default: ',')
  $( green '-v, --verbose' )  show caller file, function and line number (default: no verbose)

$( blue OUTPUTS )
  Writes 'name: value' or 'name: value, file: filename, function: funcmane, line: lineno' per line to stderr.

$( blue EXAMPLES )
  $( green '$' 0 ) export DEBUG_BASH=1 var1=1 var2=2
  $( green '$' 0 ) $( cyan "${FUNCNAME[0]} var1 var2" )
  $( grey var1 ): $( orange 1 ), $( grey var2 ): $( orange 2 )
  $( green '$' 0 ) $( cyan "${FUNCNAME[0]} var1 --no-newline var2" ); echo
  $( grey var1 ): $( orange 1 ), $( grey var2 ): $( orange 2 )
  $( green '$' 0 ) $( cyan "${FUNCNAME[0]} var1 --verbose var2" )
  $( grey var1 ): $( orange 1 ), $( grey var2 ): $( orange 2 ), $( grey file ): $( orange '<NULL>' ), \
$( grey func ): $( orange '<NULL>' ), $( grey line ): $( orange '<NULL>' )
  $( green '$' 0 ) $( cyan "${FUNCNAME[0]} var1 --verbose --no-newline var2" ); echo
  $( grey var1 ): $( orange 1 ), $( grey var2 ): $( orange 2 ), $( grey file ): $( orange '<NULL>' ), \
$( grey func ): $( orange '<NULL>' ), $( grey line ): $( orange '<NULL>' )
  $( green '$' 0 ) f() { $( cyan "${FUNCNAME[0]} var1 --verbose var2" ); }; f
  $( grey var1 ): $( orange 1 ), $( grey var2 ): $( orange 2 ), $( grey file ): $( orange main ), \
$( grey func ): $( orange f ), $( grey line ): $( orange 1 )
  $( green '$' 0 ) f() { $( cyan "${FUNCNAME[0]} var1 --verbose --separator=' |' var2" ); }; f
  $( grey var1 ): $( orange 1 ) | $( grey var2 ): $( orange 2 ) | $( grey file ): $( orange main ) | \
$( grey func ): $( orange f ) | $( grey line ): $( orange 1 )
  $( green '$' 0 ) unset DEBUG_BASH var1 var2
EOF
  )
  args "${@}" || return
  local first=true separator
  if [[ "${DEBUG_BASH-}" ]]; then
    for i in "${BASH_PARAMS[@]}"; do
      $first && first=false || separator="${BASH_SEPARATOR}"
      >&2 echo -n "${separator}$( grey "${i}" ): $( orange "${!i}" )"
    done
    if $BASH_VERBOSE; then
      echo -n "${BASH_SEPARATOR}"
      if $BASH_NO_NEWLINE; then
        called "${BASH_OPTIONS[@]}"
      fi
    elif ! $BASH_NO_NEWLINE; then
      >&2 echo
    fi
  fi
}

# TODO: Añadir --verbose en error y warning. Pero en error y warning poner en linea aparte y primero el file, etc.
error() {
  echo >&2 "$(red "${1}") ${2} $(red "${3}")"
}
info() { echo "$(green "${1}") ${2} $(green "${3}")"; }
notice() { echo "$(magenta "${1}") ${2} $(magenta "${3}")"; }
success() { echo "$(blue "${1}") ${2} $(blue "${3}")"; }
warning() {
  echo >&2 "$(yellow "${1}") ${2} $(yellow "${3}")"
}

#######################################
# Shows arguments variable names/values if 'DEBUG_BASH' is set (variables in arguments must be global).
# Globals:
#   BASH_PARAMS       arguments array without -v/--verbose, --no-std, --no-stderr and --no-stdout
#   BASH_HELP       help (with description) for function
#   BASH_NO_NEWLINE set to true if --no-newline in arguments, otherwise false
#   BASH_OPTIONS    array set with global options
#   BASH_SEPARATOR  set to value and space if --separator= in arguments (default: ', ')
#   BASH_VERBOSE    set to true if --v/--verbose in arguments, otherwise false
#   DEBUG_BASH      must be set and exported to show 'name: value' for arguments
# Arguments:
#   var1, var2 ...  variable names to show values (must be exported).
#   --desc          show description.
#   -h, --help      show help.
# Options:
#   --no-newline    do not add newline in output (default: false)
#   --separator=    separator, space will be added and remove --no-stdout in 'BASH_PARAMS' (default: ',')
#   -v, --verbose   show caller file, function and line number (default: false)
# Outputs:
#   Writes 'name: value' or 'name: value, file: filename, function: funcmane, line: lineno' to stderr.
#######################################
# TODO: Cambiar el echo de los colores por el --no-newline
black() {
  BASH_HELP=$(
    cat <<EOF
$( blue NAME )
  $( green "${FUNCNAME[0]}" ) - shows arguments variable names/values if 'DEBUG_BASH' is set (variables in arguments \
must be global)

$( blue SYNOPSIS )
  $( green "${FUNCNAME[0]}" ) arg1 arg2
  $( green "${FUNCNAME[0]}" ) [arg1 [arg2] [...]] [--no-newline] [--separator=<value>] [-v, --verbose]

$( blue DESCRIPTION )
  Shows arguments variable names/values if 'DEBUG_BASH' is set (variables in arguments must be global)

$( blue GLOBALS )
  $( green BASH_PARAMS )        arguments array without -v/--verbose, --no-std, --no-stderr and --no-stdout
  $( green BASH_HELP )        help (with description) for function
  $( green BASH_NO_NEWLINE )  do not add newline in output
  $( green BASH_SEPARATOR )   set to value and space if --separator= in arguments (default: ', ')
  $( green BASH_VERBOSE )     set to true if --v/--verbose in arguments, otherwise false
  $( green DEBUG_BASH )       must be set and exported to show 'name: value' for arguments

$( blue ARGUMENTS )
  $( green 'arg1 arg2 ...' )  shows odd arguments in ${FUNCNAME[0]} and even in white
  $( green --desc )           show description.
  $( green '-h, --help' )     show help.

$( blue OPTIONS )
  $( green --no-newline )     do not add newline in output (default: new line at the end)
  $( green --separator= )     separator, space will be added and remove --no-stdout in 'BASH_PARAMS' (default: ',')
  $( green '-v, --verbose' )  show caller file, function and line number (default: no verbose)

$( blue OUTPUTS )
  Shows odd arguments in ${FUNCNAME[0]} and even in white.

$( blue EXAMPLES )
  $( green '$' 0 ) $( cyan "${FUNCNAME[0]} arg1 'arg2 2' arg3" )
  $( grey var1 ): $( orange 1 ), $( grey var2 ): $( orange 2 )
  $( green '$' 0 ) $( cyan "${FUNCNAME[0]} var1 --no-newline var2" ); echo
  $( grey var1 ): $( orange 1 ), $( grey var2 ): $( orange 2 )
  $( green '$' 0 ) $( cyan "${FUNCNAME[0]} var1 --verbose var2" )
  $( grey var1 ): $( orange 1 ), $( grey var2 ): $( orange 2 ), $( grey file ): $( orange '<NULL>' ), \
$( grey func ): $( orange '<NULL>' ), $( grey line ): $( orange '<NULL>' )
  $( green '$' 0 ) $( cyan "${FUNCNAME[0]} var1 --verbose --no-newline var2" ); echo
  $( grey var1 ): $( orange 1 ), $( grey var2 ): $( orange 2 ), $( grey file ): $( orange '<NULL>' ), \
$( grey func ): $( orange '<NULL>' ), $( grey line ): $( orange '<NULL>' )
  $( green '$' 0 ) f() { $( cyan "${FUNCNAME[0]} var1 --verbose var2" ); }; f
  $( grey var1 ): $( orange 1 ), $( grey var2 ): $( orange 2 ), $( grey file ): $( orange main ), \
$( grey func ): $( orange f ), $( grey line ): $( orange 1 )
  $( green '$' 0 ) f() { $( cyan "${FUNCNAME[0]} var1 --verbose --separator=' |' var2" ); }; f
  $( grey var1 ): $( orange 1 ) | $( grey var2 ): $( orange 2 ) | $( grey file ): $( orange main ) | \
$( grey func ): $( orange f ) | $( grey line ): $( orange 1 )
EOF
  )
  args "${@}" || return
  local first=true separator
  if [[ "${DEBUG_BASH-}" ]]; then
    for i in "${BASH_PARAMS[@]}"; do
      $first && first=false || separator="${BASH_SEPARATOR}"
      >&2 echo -n "${separator}$( tput setaf 0 )${i}$( tput sgr0 )"
    done
    if $BASH_VERBOSE; then
      echo -n "${BASH_SEPARATOR}"
      if $BASH_NO_NEWLINE; then
        called "${BASH_OPTIONS[@]}"
      fi
    elif ! $BASH_NO_NEWLINE; then
      >&2 echo
    fi
  fi
}

blue() { printf '%s' "$(tput setaf 4)${1}$(tput sgr0)"; [[ "${2-}" ]] || echo; }
cyan() { printf '%s' "$(tput setaf 6)${1}$(tput sgr0)"; [[ "${2-}" ]] || echo; }
green() { printf '%s' "$(tput setaf 2)${1}$(tput sgr0)"; [[ "${2-}" ]] || echo; }
grey() { printf '%s' "$(tput setaf 7)${1}$(tput sgr0)"; [[ "${2-}" ]] || echo; }
magenta() { printf '%s' "$(tput setaf 5)${1}$(tput sgr0)"; [[ "${2-}" ]] || echo; }
orange() { printf '%s' "$(tput setaf 9)${1}$(tput sgr0)"; [[ "${2-}" ]] || echo; }
red() { printf '%s' "$(tput setaf 1)${1}$(tput sgr0)"; [[ "${2-}" ]] || echo; }
yellow() { printf '%s' "$(tput setaf 3)${1}$(tput sgr0)"; [[ "${2-}" ]] || echo; }

#######################################
# Perform bootstrap and export helper functions and vars when is sourced.
# Globals:
#   BASH_HELP      Help (with description) for function.
#   BASH_EXPORT    variables exported.
#   MACOS          true or false.
# Arguments:
#   --descriptions Show function names and descriptions in '${script}'.
#   --functions    Show functions in '${script}'.
#   --globals      Show vars exported in '${script}'.
#   -h, --help     Show help.
#   --desc         Show description.
# Outputs:
#   Writes desc, descriptions, exports or functions to stdout.
# Returns:
#   0 if running successfully, non-zero on error.
#######################################
main() {
  local script="${BASH_SOURCE[0]##*/}"
  BASH_HELP=$(
    cat <<EOF
NAME
  ${script} - Perform bootstrap and export helper functions when is sourced.

SYNOPSIS
  ${script}
  ${script} --descriptions
  ${script} --exports
  ${script} --functions
  ${script} [-h | --help]
  ${script} [--desc]

DESCRIPTION
  Perform bootstrap and adds bash functions when is sourced.
  Export functions in '${BASH_SOURCE[0]}'.

GLOBALS
  BASH_HELP      Help (with description) for function.
  BASH_EXPORT    variables exported.
  MACOS          true or false

ARGUMENTS
  --descriptions   Show function names and descriptions in '${script}'.
  --exports        Show vars exported in '${script}'.
  --functions      Show functions in '${script}'.
  -h, --help       Show help.
  --desc           Show description.

OUTPUTS:
  Writes desc, descriptions, exports or functions to stdout.

RETURNS
  0 if running successfully, non-zero on error.

EXAMPLES
  $ ${script}
  $ ${script} --descriptions
  $ ${script} --exports
  $ ${script} --functions
  $ ${script} --help
EOF
  )
  export BASH_HELP
  export BASH_PARAMS=() BASH_NO_NEWLINE=false BASH_NO_STDERR=false BASH_NO_STDOUT=false  # avoid shellcheck problems.
  export BASH_RC=false BASH_RV=() BASH_STDIN=() BASH_STDERR=true BASH_STDOUT=false     # avoid shellcheck problems.
  export BASH_OPTIONS=() BASH_SEPARATOR=', ' BASH_VERBOSE=false                                                            # avoid shellcheck problems.

  args "${@}" || return 0

  local value var
#  declare -A BASH_EXPORT=( [SUDOC]="$( command -v sudo )" [UNAME]="$( uname -s )" \
#    [BASH_COMPLETION]=$( if [[ "${BASH_VERSION-}" &&  "${PS1-}" && "${BASH_COMPLETION_VERSINFO-}" && \
#    "${BASH_VERSINFO[0]}" -gt 4 ]]; then true; else false; fi ) )

#  for var in Darwin Linux; do
#    [[ "${BASH_EXPORT[UNAME]}" != "${var}" ]] || BASH_EXPORT[${var^^}]=1
#  done
#  if test -f /etc/os-release; then
#    IFS=$'='; while read -r var value; do
#      case "${var}" in
#        ID) BASH_EXPORT[${var^^}]=1; BASH_EXPORT[DIST_ID]="${value}" ;;
#        ID_LIKE=debian) BASH_EXPORT[DEBIAN]=1 ;;
#        VERSION_ID) BASH_EXPORT[DIST_VERSION]="${value}" ;;
#        VERSION_CODENAME) BASH_EXPORT[DIST_CODENAME]="${value}" ;;
#      esac
#    done < /etc/os-release
#    BASH_EXPORT[MACOS]=false
#  elif [[ "${DARWIN-}" ]]; then
#    BASH_EXPORT[DIST_ID]="macos"
#    BASH_EXPORT[DIST_VERSION]="$( sw_vers -productVersion )"
#    case "$( awk -F '.' '{ print $1.$2 }' <<< "${BASH_EXPORT[DIST_VERSION]}" )" in
#      10.13) BASH_EXPORT[DIST_CODENAME]="High Sierra" ;;
#      10.14) BASH_EXPORT[DIST_CODENAME]="Mojave" ;;
#      10.15) BASH_EXPORT[DIST_CODENAME]="Catalina" ;;
#      10.16) BASH_EXPORT[DIST_CODENAME]="Big Sur" ;;
#      10.17) BASH_EXPORT[DIST_CODENAME]="Big Sur" ;;
#      *) BASH_EXPORT[DIST_CODENAME]="Other" ;;
#    esac
#  fi
#  for i in "${!BASH_EXPORT[@]}"; do
#    # bashsupport disable=BP2001
#    export "${i?}"
#  done

  filefuncs --export
  # TODO: Tendría que usar el BASH_PARAMS y asi tener el verbose, etc como hacia en el debug?
  #   pero es un peñazo añadir el verbose si esta la global,.... etc.
  for arg; do
    case "${arg}" in
      --descriptions) filefuncs --descriptions ;;
      --exports)
        export DEBUG_BASH=1
        debug "$( printf '%s\n' "${BASH_EXPORT[@]}" | sort -u )"
        export DEBUG_BASH=0
        ;;
      --functions) filefuncs "" ;;
    esac
    shift
  done
  _main
}

main "${@}"
